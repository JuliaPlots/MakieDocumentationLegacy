<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference AbstractPlotting · Makie Plotting Ecosystem</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="assets/syntaxtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Makie Plotting Ecosystem logo"/></a><div class="docs-package-name"><span class="docs-autofit">Makie Plotting Ecosystem</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="basic-tutorial.html">Basic Tutorial</a></li><li><a class="tocitem" href="makielayout/tutorial.html">Layout Tutorial</a></li><li><a class="tocitem" href="animation.html">Animations</a></li><li><a class="tocitem" href="interaction.html">Observables &amp; Interaction</a></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Plotting Functions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="plotting_functions/arrows.html">arrows</a></li><li><a class="tocitem" href="plotting_functions/band.html">band</a></li><li><a class="tocitem" href="plotting_functions/barplot.html">barplot</a></li><li><a class="tocitem" href="plotting_functions/contour.html">contour</a></li><li><a class="tocitem" href="plotting_functions/contourf.html">contourf</a></li><li><a class="tocitem" href="plotting_functions/density.html">density</a></li><li><a class="tocitem" href="plotting_functions/errorbars.html">errorbars</a></li><li><a class="tocitem" href="plotting_functions/heatmap.html">heatmap</a></li><li><a class="tocitem" href="plotting_functions/hist.html">hist</a></li><li><a class="tocitem" href="plotting_functions/image.html">image</a></li><li><a class="tocitem" href="plotting_functions/lines.html">lines</a></li><li><a class="tocitem" href="plotting_functions/linesegments.html">linesegments</a></li><li><a class="tocitem" href="plotting_functions/mesh.html">mesh</a></li><li><a class="tocitem" href="plotting_functions/meshscatter.html">meshscatter</a></li><li><a class="tocitem" href="plotting_functions/poly.html">poly</a></li><li><a class="tocitem" href="plotting_functions/rangebars.html">rangebars</a></li><li><a class="tocitem" href="plotting_functions/scatter.html">scatter</a></li><li><a class="tocitem" href="plotting_functions/scatterlines.html">scatterlines</a></li><li><a class="tocitem" href="plotting_functions/stem.html">stem</a></li><li><a class="tocitem" href="plotting_functions/surface.html">surface</a></li><li><a class="tocitem" href="plotting_functions/text.html">text</a></li><li><a class="tocitem" href="plotting_functions/volume.html">volume</a></li></ul></li><li><a class="tocitem" href="theming.html">Theming</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="plot_method_signatures.html">Plot Method Signatures</a></li><li><a class="tocitem" href="figure.html">Figure</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Layoutables &amp; Widgets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="makielayout/layoutables.html">Layoutables</a></li><li><a class="tocitem" href="makielayout/axis.html">Axis</a></li><li><a class="tocitem" href="makielayout/box.html">Box</a></li><li><a class="tocitem" href="makielayout/button.html">Button</a></li><li><a class="tocitem" href="makielayout/colorbar.html">Colorbar</a></li><li><a class="tocitem" href="makielayout/gridlayout.html">GridLayout</a></li><li><a class="tocitem" href="makielayout/label.html">Label</a></li><li><a class="tocitem" href="makielayout/legend.html">Legend</a></li><li><a class="tocitem" href="makielayout/lscene.html">LScene</a></li><li><a class="tocitem" href="makielayout/menu.html">Menu</a></li><li><a class="tocitem" href="makielayout/slider.html">Slider</a></li><li><a class="tocitem" href="makielayout/toggle.html">Toggle</a></li></ul></li><li><a class="tocitem" href="makielayout/layouting.html">How layouts work</a></li><li><a class="tocitem" href="generated/colors.html">Colors</a></li><li><a class="tocitem" href="generated/plot-attributes.html">Plot attributes</a></li><li><a class="tocitem" href="recipes.html">Plot Recipes</a></li><li><a class="tocitem" href="backends_and_output.html">Backends &amp; Output</a></li><li><a class="tocitem" href="scenes.html">Scenes</a></li><li><a class="tocitem" href="lighting.html">Lighting</a></li><li><a class="tocitem" href="cameras.html">Cameras</a></li><li><a class="tocitem" href="faq.html">Frequently Asked Questions</a></li><li class="is-active"><a class="tocitem" href="abstractplotting_api.html">API Reference AbstractPlotting</a><ul class="internal"><li><a class="tocitem" href="#Exported"><span>Exported</span></a></li><li><a class="tocitem" href="#Unexported"><span>Unexported</span></a></li></ul></li><li><a class="tocitem" href="makielayout/reference.html">API Reference MakieLayout</a></li><li><a class="tocitem" href="generated/axis.html">Integrated Axes (Axis2D / Axis3D)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="abstractplotting_api.html">API Reference AbstractPlotting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="abstractplotting_api.html">API Reference AbstractPlotting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/master/docs/src/abstractplotting_api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Exported"><a class="docs-heading-anchor" href="#Exported">Exported</a><a id="Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Exported" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Absolute" href="#AbstractPlotting.Absolute"><code>AbstractPlotting.Absolute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Absolute</code></pre><p>Force transformation to be absolute, not relative to the current state. This is the default setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/transformation.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Accum" href="#AbstractPlotting.Accum"><code>AbstractPlotting.Accum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Accum</code></pre><p>Force transformation to be relative to the current state, not absolute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/transformation.jl#L145-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Attributes" href="#AbstractPlotting.Attributes"><code>AbstractPlotting.Attributes</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Main structure for holding attributes, for theming plots etc! Will turn all values into nodes, so that they can be updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/dictlike.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Billboard" href="#AbstractPlotting.Billboard"><code>AbstractPlotting.Billboard</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Billboard attribute to always have a primitive face the camera. Can be used for rotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/types.jl#L158-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Events" href="#AbstractPlotting.Events"><code>AbstractPlotting.Events</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This struct provides accessible <code>Observable</code>s to monitor the events associated with a Scene.</p><p><strong>Fields</strong></p><ul><li><p><code>window_area::Observable{GeometryBasics.HyperRectangle{2,Int64}}</code></p><p>The area of the window in pixels, as a <code>Rect2D</code>.</p></li></ul><ul><li><p><code>window_dpi::Observable{Float64}</code></p><p>The DPI resolution of the window, as a <code>Float64</code>.</p></li></ul><ul><li><p><code>window_open::Observable{Bool}</code></p><p>The state of the window (open =&gt; true, closed =&gt; false).</p></li></ul><ul><li><p><code>mousebuttons::Observable{Set{AbstractPlotting.Mouse.Button}}</code></p><p>The pressed mouse buttons. Updates when a mouse button is pressed.</p><p>See also <a href="abstractplotting_api.html#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>mouseposition::Observable{Tuple{Float64,Float64}}</code></p><p>The position of the mouse as a <code>NTuple{2, Float64}</code>. Updates whenever the mouse moves.</p></li></ul><ul><li><p><code>mousedrag::Observable{AbstractPlotting.Mouse.DragEnum}</code></p><p>The state of the mouse drag, represented by an enumerator of <code>DragEnum</code>.</p></li><li><p><code>scroll::Observable{Tuple{Float64,Float64}}</code></p><p>The direction of scroll</p></li></ul><ul><li><p><code>keyboardbuttons::Observable{Set{AbstractPlotting.Keyboard.Button}}</code></p><p>See also <a href="abstractplotting_api.html#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>unicode_input::Observable{Array{Char,1}}</code></p></li><li><p><code>dropped_files::Observable{Array{String,1}}</code></p></li><li><p><code>hasfocus::Observable{Bool}</code></p><p>Whether the Scene window is in focus or not.</p></li></ul><ul><li><code>entered_window::Observable{Bool}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/types.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Pixel" href="#AbstractPlotting.Pixel"><code>AbstractPlotting.Pixel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Unit in pixels on screen. This one is a bit tricky, since it refers to a static attribute (pixels on screen don&#39;t change) but since every visual is attached to a camera, the exact scale might change. So in the end, this is just relative to some normed camera - the value on screen, depending on the camera, will not actually sit on those pixels. Only camera that guarantees the correct mapping is the <code>:pixel</code> camera type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/units.jl#L58-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.PlotSpec" href="#AbstractPlotting.PlotSpec"><code>AbstractPlotting.PlotSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PlotSpec{P&lt;:AbstractPlot}(args...; kwargs...)</code></p><p>Object encoding positional arguments (<code>args</code>), a <code>NamedTuple</code> of attributes (<code>kwargs</code>) as well as plot type <code>P</code> of a basic plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/types.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Reverse" href="#AbstractPlotting.Reverse"><code>AbstractPlotting.Reverse</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Reverses the attribute T upon conversion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L927-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Scene" href="#AbstractPlotting.Scene"><code>AbstractPlotting.Scene</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Scene TODO document this</code></pre><p><strong>Constructors</strong></p><p><strong>Fields</strong></p><ul><li><p><code>parent</code></p><p>The parent of the Scene; if it is a top-level Scene, <code>parent == nothing</code>.</p></li><li><p><code>events</code></p><p><a href="abstractplotting_api.html#AbstractPlotting.Events"><code>Events</code></a> associated with the Scene.</p></li><li><p><code>px_area</code></p><p>The current pixel area of the Scene.</p></li><li><p><code>clear</code></p><p>Whether the scene should be cleared.</p></li><li><p><code>camera</code></p><p>The <code>Camera</code> associated with the Scene.</p></li><li><p><code>camera_controls</code></p><p>The controls for the camera of the Scene.</p></li><li><p><code>data_limits</code></p><p>The limits of the data plotted in this scene. Can&#39;t be set by user and is only used to store calculated data bounds.</p></li></ul><ul><li><p><code>transformation</code></p><p>The <a href="abstractplotting_api.html#AbstractPlotting.Transformation"><code>Transformation</code></a> of the Scene.</p></li><li><p><code>plots</code></p><p>The plots contained in the Scene.</p></li><li><p><code>theme</code></p></li><li><p><code>attributes</code></p></li><li><p><code>children</code></p><p>Children of the Scene inherit its transformation.</p></li><li><p><code>current_screens</code></p><p>The Screens which the Scene is displayed to.</p></li></ul><ul><li><p><code>updated</code></p><p>Signal to indicate whether layouting should happen. If updated to true, the Scene will be layouted according to its attributes (<code>raw</code>, <code>center</code>, or <code>scale_plot</code>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.SceneSpace" href="#AbstractPlotting.SceneSpace"><code>AbstractPlotting.SceneSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Unit space of the scene it&#39;s displayed on. Also referred to as data units</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/units.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Transformation" href="#AbstractPlotting.Transformation"><code>AbstractPlotting.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Holds the transformations for Scenes.</p><p><strong>Fields</strong></p><ul><li><p><code>parent::Base.RefValue{AbstractPlotting.Transformable}</code></p></li><li><p><code>translation::Observable{Vec{3,Float32}}</code></p></li><li><p><code>scale::Observable{Vec{3,Float32}}</code></p></li><li><p><code>rotation::Observable{Quaternion{Float32}}</code></p></li><li><p><code>model::Observable{StaticArrays.SArray{Tuple{4,4},Float32,2,16}}</code></p></li><li><p><code>flip::Observable{Tuple{Bool,Bool,Bool}}</code></p></li><li><p><code>align::Observable{Vec{2,Float32}}</code></p></li><li><p><code>transform_func::Observable{Any}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/types.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.VideoStream-Tuple{Scene}" href="#AbstractPlotting.VideoStream-Tuple{Scene}"><code>AbstractPlotting.VideoStream</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">VideoStream(scene::Scene, framerate = 24)</code></pre><p>Returns a stream and a buffer that you can use, which don&#39;t allocate for new frames. Use <a href="abstractplotting_api.html#AbstractPlotting.recordframe!-Tuple{VideoStream}"><code>recordframe!(stream)</code></a> to add new video frames to the stream, and <a href="abstractplotting_api.html#FileIO.save-Tuple{String,Union{Figure, AbstractPlotting.FigureAxisPlot, Scene}}"><code>save(path, stream)</code></a> to save the video.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L333-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Pattern-Tuple{Array{var&quot;#s80&quot;,2} where var&quot;#s80&quot;&lt;:Colorant}" href="#AbstractPlotting.Pattern-Tuple{Array{var&quot;#s80&quot;,2} where var&quot;#s80&quot;&lt;:Colorant}"><code>AbstractPlotting.Pattern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pattern(image)
Pattern(mask[; color1, color2])</code></pre><p>Creates an <code>ImagePattern</code> from an <code>image</code> (a matrix of colors) or a <code>mask</code> (a matrix of real numbers). The pattern can be passed as a <code>color</code> to a plot to texture it. If a <code>mask</code> is passed, one can specify to colors between which colors are interpolated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/patterns.jl#L19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Pattern-Tuple{String}" href="#AbstractPlotting.Pattern-Tuple{String}"><code>AbstractPlotting.Pattern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pattern(style::String = &quot;/&quot;; kwargs...)
Pattern(style::Char = &#39;/&#39;; kwargs...)</code></pre><p>Creates a line pattern based on the given argument. Available patterns are <code>&#39;/&#39;</code>, <code>&#39;\&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;|&#39;</code>, <code>&#39;x&#39;</code>, and <code>&#39;+&#39;</code>. All keyword arguments correspond to the keyword arguments for <a href="abstractplotting_api.html#AbstractPlotting.LinePattern-Tuple{}"><code>LinePattern</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/patterns.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.annotations!-Tuple" href="#AbstractPlotting.annotations!-Tuple"><code>AbstractPlotting.annotations!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">annotations(strings::Vector{String}, positions::Vector{Point})</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.annotations!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.annotations-Tuple" href="#AbstractPlotting.annotations-Tuple"><code>AbstractPlotting.annotations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">annotations(strings::Vector{String}, positions::Vector{Point})</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.annotations,T} where T</code> are: </p><pre><code class="nohighlight">  _glyphlayout    &quot;nothing&quot;
  align           (:left, :bottom)
  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  diffuse         Float32[0.4, 0.4, 0.4]
  font            &quot;Dejavu Sans&quot;
  justification   AbstractPlotting.Automatic()
  lightposition   :eyeposition
  lineheight      1.0
  linewidth       1
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  position        Float32[0.0, 0.0]
  rotation        0.0
  shininess       32.0f0
  space           :screen
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  strokecolor     (:black, 0.0)
  strokewidth     0
  textsize        20
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.arc!-Tuple" href="#AbstractPlotting.arc!-Tuple"><code>AbstractPlotting.arc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f0(0), 1, 0.0, π)</code> <code>arc(Point2f0(1, 2), 0.3. π, -π)</code></p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.arc!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.arc-Tuple" href="#AbstractPlotting.arc-Tuple"><code>AbstractPlotting.arc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f0(0), 1, 0.0, π)</code> <code>arc(Point2f0(1, 2), 0.3. π, -π)</code></p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.arc,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  lightposition   :eyeposition
  linestyle       &quot;nothing&quot;
  linewidth       1.0
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  resolution      361
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.arrows!-Tuple" href="#AbstractPlotting.arrows!-Tuple"><code>AbstractPlotting.arrows!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each &#39;row&#39; is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.arrows!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.arrows-Tuple" href="#AbstractPlotting.arrows-Tuple"><code>AbstractPlotting.arrows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each &#39;row&#39; is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.arrows,T} where T</code> are: </p><pre><code class="nohighlight">  arrowcolor   :black
  arrowhead    AbstractPlotting.Automatic()
  arrowsize    0.3
  arrowtail    &quot;nothing&quot;
  colormap     :viridis
  lengthscale  1.0f0
  linecolor    :black
  linestyle    &quot;nothing&quot;
  linewidth    1
  normalize    false
  scale        Float32[1.0, 1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.available_gradients-Tuple{}" href="#AbstractPlotting.available_gradients-Tuple{}"><code>AbstractPlotting.available_gradients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">available_gradients()</code></pre><p>Prints all available gradient names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L915-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.axis3d!-Tuple" href="#AbstractPlotting.axis3d!-Tuple"><code>AbstractPlotting.axis3d!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">axis3d!(args; attributes...)
</code></pre><p>Plots a 3-dimensional OldAxis.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.axis3d!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.axis3d-Tuple" href="#AbstractPlotting.axis3d-Tuple"><code>AbstractPlotting.axis3d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">axis3d(args; attributes...)
</code></pre><p>Plots a 3-dimensional OldAxis.</p><p><strong>Attributes</strong></p><p>OldAxis attributes and their defaults for <code>Combined{AbstractPlotting.axis3d,T} where T</code> are: </p><pre><code class="nohighlight">    showaxis: (true, true, true)
    showgrid: (true, true, true)
    padding: 0.1
    visible: true
    ticks: 
        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)
        font: (&quot;Dejavu Sans&quot;, &quot;Dejavu Sans&quot;, &quot;Dejavu Sans&quot;)
        ranges_labels: (AbstractPlotting.Automatic(), AbstractPlotting.Automatic())
        formatter: plain
        textcolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0))
        align: ((:left, :center), (:right, :center), (:right, :center))
        textsize: (5, 5, 5)
        gap: 3
    frame: 
        axiscolor: (:black, :black, :black)
        axislinewidth: (1.5, 1.5, 1.5)
        linewidth: (1, 1, 1)
        linecolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0))
    names: 
        axisnames: (&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)
        font: (&quot;Dejavu Sans&quot;, &quot;Dejavu Sans&quot;, &quot;Dejavu Sans&quot;)
        textcolor: (:black, :black, :black)
        align: ((:left, :center), (:right, :center), (:right, :center))
        textsize: (6.0, 6.0, 6.0)
        gap: 3
    showticks: (true, true, true)
    scale: Float32[1.0, 1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.band!-Tuple" href="#AbstractPlotting.band!-Tuple"><code>AbstractPlotting.band!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>band(x, ylower, yupper; kwargs...) band(lower, upper; kwargs...)</p><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.band!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.band-Tuple" href="#AbstractPlotting.band-Tuple"><code>AbstractPlotting.band</code></a> — <span class="docstring-category">Method</span></header><section><div><p>band(x, ylower, yupper; kwargs...) band(lower, upper; kwargs...)</p><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.band,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.2f0)
  colormap        :viridis
  colorrange      AbstractPlotting.Automatic()
  diffuse         Float32[0.4, 0.4, 0.4]
  interpolate     false
  lightposition   :eyeposition
  linewidth       1
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shading         true
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.barplot!-Tuple" href="#AbstractPlotting.barplot!-Tuple"><code>AbstractPlotting.barplot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height.  <code>x</code> and <code>y</code> should be 1 dimensional.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.barplot!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.barplot-Tuple" href="#AbstractPlotting.barplot-Tuple"><code>AbstractPlotting.barplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height.  <code>x</code> and <code>y</code> should be 1 dimensional.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.barplot,T} where T</code> are: </p><pre><code class="nohighlight">  color        :black
  colormap     :viridis
  colorrange   AbstractPlotting.Automatic()
  direction    :y
  fillto       0.0
  marker       GeometryBasics.HyperRectangle{N,T} where T where N
  strokecolor  :white
  strokewidth  0
  visible      true
  width        AbstractPlotting.Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.boxplot!-Tuple" href="#AbstractPlotting.boxplot!-Tuple"><code>AbstractPlotting.boxplot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxplot(x, y; kwargs...)</code></pre><p>Draw a Tukey style boxplot. The boxplot has 3 components:</p><ul><li>a <code>crossbar</code> spanning the interquartile (IQR) range with a midline marking the   median</li><li>an <code>errorbar</code> whose whiskers span <code>range * iqr</code></li><li>points marking outliers, that is, data outside the whiskers</li></ul><p><strong>Arguments</strong></p><ul><li><code>x</code>: positions of the categories</li><li><code>y</code>: variables within the boxes</li></ul><p><strong>Keywords</strong></p><ul><li><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</li><li><code>width=0.8</code>: width of the box</li><li><code>show_notch=false</code>: draw the notch</li><li><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</li><li><code>show_median=true</code>: show median as midline</li><li><code>range</code>: multiple of IQR controlling whisker length</li><li><code>whiskerwidth</code>: multiplier of <code>width</code> for width of T&#39;s on whiskers, or   <code>:match</code> to match <code>width</code></li><li><code>show_outliers</code>: show outliers as points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.boxplot-Tuple" href="#AbstractPlotting.boxplot-Tuple"><code>AbstractPlotting.boxplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxplot(x, y; kwargs...)</code></pre><p>Draw a Tukey style boxplot. The boxplot has 3 components:</p><ul><li>a <code>crossbar</code> spanning the interquartile (IQR) range with a midline marking the   median</li><li>an <code>errorbar</code> whose whiskers span <code>range * iqr</code></li><li>points marking outliers, that is, data outside the whiskers</li></ul><p><strong>Arguments</strong></p><ul><li><code>x</code>: positions of the categories</li><li><code>y</code>: variables within the boxes</li></ul><p><strong>Keywords</strong></p><ul><li><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</li><li><code>width=0.8</code>: width of the box</li><li><code>show_notch=false</code>: draw the notch</li><li><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</li><li><code>show_median=true</code>: show median as midline</li><li><code>range</code>: multiple of IQR controlling whisker length</li><li><code>whiskerwidth</code>: multiplier of <code>width</code> for width of T&#39;s on whiskers, or   <code>:match</code> to match <code>width</code></li><li><code>show_outliers</code>: show outliers as points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.broadcast_foreach-Tuple{Any,Vararg{Any,N} where N}" href="#AbstractPlotting.broadcast_foreach-Tuple{Any,Vararg{Any,N} where N}"><code>AbstractPlotting.broadcast_foreach</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Like broadcast but for foreach. Doesn&#39;t care about shape and treats Tuples &amp;&amp; StaticVectors as scalars.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L145-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.cam2d!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}" href="#AbstractPlotting.cam2d!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}"><code>AbstractPlotting.cam2d!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cam2d!(scene::SceneLike, kwargs...)</code></pre><p>Creates a 2D camera for the given Scene.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera2d.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.cam2d-Tuple{Scene}" href="#AbstractPlotting.cam2d-Tuple{Scene}"><code>AbstractPlotting.cam2d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a subscene with a pixel camera</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L303-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.cam3d!" href="#AbstractPlotting.cam3d!"><code>AbstractPlotting.cam3d!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cam3d!(scene; kwargs...)</code></pre><p>An alias to <a href="abstractplotting_api.html#AbstractPlotting.cam3d_turntable!-Tuple{Any}"><code>cam3d_turntable!</code></a>. Creates a 3D camera for <code>scene</code>, which rotates around the plot&#39;s axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera3d.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.cam3d_cad!-Tuple{Any}" href="#AbstractPlotting.cam3d_cad!-Tuple{Any}"><code>AbstractPlotting.cam3d_cad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cam3d_cad!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code> which rotates around the <em>viewer</em>&#39;s &quot;up&quot; axis - similarly to how it&#39;s done in CAD software cameras.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera3d.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.campixel!-Tuple{Any}" href="#AbstractPlotting.campixel!-Tuple{Any}"><code>AbstractPlotting.campixel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">campixel!(scene)</code></pre><p>Creates a pixel-level camera for the <code>Scene</code>.  No controls!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera2d.jl#L276-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.contour!-Tuple" href="#AbstractPlotting.contour!-Tuple"><code>AbstractPlotting.contour!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>contour(x, y, z)</p><p>Creates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.contour!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.contour-Tuple" href="#AbstractPlotting.contour-Tuple"><code>AbstractPlotting.contour</code></a> — <span class="docstring-category">Method</span></header><section><div><p>contour(x, y, z)</p><p>Creates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.contour,T} where T</code> are: </p><pre><code class="nohighlight">  alpha           1.0
  ambient         Float32[0.55, 0.55, 0.55]
  color           &quot;nothing&quot;
  colormap        :viridis
  colorrange      AbstractPlotting.Automatic()
  diffuse         Float32[0.4, 0.4, 0.4]
  fillrange       false
  levels          5
  lightposition   :eyeposition
  linewidth       1.0
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.contour3d!-Tuple" href="#AbstractPlotting.contour3d!-Tuple"><code>AbstractPlotting.contour3d!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>contour3d(x, y, z)</p><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.contour3d!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.contour3d-Tuple" href="#AbstractPlotting.contour3d-Tuple"><code>AbstractPlotting.contour3d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>contour3d(x, y, z)</p><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.contour3d,T} where T</code> are: </p><pre><code class="nohighlight">  alpha           1.0
  ambient         Float32[0.55, 0.55, 0.55]
  color           &quot;nothing&quot;
  colormap        :viridis
  colorrange      AbstractPlotting.Automatic()
  diffuse         Float32[0.4, 0.4, 0.4]
  fillrange       false
  levels          5
  lightposition   :eyeposition
  linewidth       1.0
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.contourf!-Tuple" href="#AbstractPlotting.contourf!-Tuple"><code>AbstractPlotting.contourf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled contour of the height information in <code>zs</code> at horizontal grid positions <code>xs</code> and vertical grid positions <code>ys</code>.</p><p>The attribute <code>levels</code> can be either</p><ul><li>an <code>Int</code> that produces n equally wide levels or bands</li><li>an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 levels or bands</li></ul><p>If you want to show a band from <code>-Inf</code> to the low edge, set <code>extendlow</code> to <code>:auto</code> for the same color as the first level, or specify a different color (default <code>nothing</code> means no extended band) If you want to show a band from the high edge to <code>Inf</code>, set <code>extendhigh</code> to <code>:auto</code> for the same color as the last level, or specify a different color (default <code>nothing</code> means no extended band)</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.contourf!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.contourf-Tuple" href="#AbstractPlotting.contourf-Tuple"><code>AbstractPlotting.contourf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled contour of the height information in <code>zs</code> at horizontal grid positions <code>xs</code> and vertical grid positions <code>ys</code>.</p><p>The attribute <code>levels</code> can be either</p><ul><li>an <code>Int</code> that produces n equally wide levels or bands</li><li>an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 levels or bands</li></ul><p>If you want to show a band from <code>-Inf</code> to the low edge, set <code>extendlow</code> to <code>:auto</code> for the same color as the first level, or specify a different color (default <code>nothing</code> means no extended band) If you want to show a band from the high edge to <code>Inf</code>, set <code>extendhigh</code> to <code>:auto</code> for the same color as the last level, or specify a different color (default <code>nothing</code> means no extended band)</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.contourf,T} where T</code> are: </p><pre><code class="nohighlight">  colormap    :viridis
  extendhigh  &quot;nothing&quot;
  extendlow   &quot;nothing&quot;
  levels      10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x, y, z)::(Vector)</code></pre><p>Takes vectors <code>x</code>, <code>y</code>, and <code>z</code> and turns it into a vector of 3D points of the values from <code>x</code>, <code>y</code>, and <code>z</code>. <code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x, y)::(Vector)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and turns it into a vector of 2D points of the values from <code>x</code> and <code>y</code>.</p><p><code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, y)::Vector</code></pre><p>Takes vector <code>y</code> and generates a range from 1 to the length of <code>y</code>, for plotting on an arbitrary <code>x</code> axis.</p><p><code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L173-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryBasics.GeometryPrimitive}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryBasics.GeometryPrimitive}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input GeometryPrimitive <code>x</code> and decomposes it to points. <code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryBasics.HyperRectangle{2,T} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryBasics.HyperRectangle{2,T} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input <code>Rect</code> <code>x</code> and decomposes it to points.</p><p><code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L215-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryBasics.LineString}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryBasics.LineString}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(PB, LineString)</code></pre><p>Takes an input <code>LineString</code> and decomposes it to points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L287-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryBasics.Polygon}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,GeometryBasics.Polygon}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(PB, Polygon)</code></pre><p>Takes an input <code>Polygon</code> and decomposes it to points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L311-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,Union{Array{var&quot;#s167&quot;,N} where N where var&quot;#s167&quot;&lt;:GeometryBasics.LineString, GeometryBasics.MultiLineString}}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,Union{Array{var&quot;#s167&quot;,N} where N where var&quot;#s167&quot;&lt;:GeometryBasics.LineString, GeometryBasics.MultiLineString}}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(PB, Union{Array{&lt;:LineString}, MultiLineString})</code></pre><p>Takes an input <code>Array{LineString}</code> or a <code>MultiLineString</code> and decomposes it to points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,Union{Array{var&quot;#s167&quot;,N} where N where var&quot;#s167&quot;&lt;:GeometryBasics.Polygon, GeometryBasics.MultiPolygon}}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.PointBased,Union{Array{var&quot;#s167&quot;,N} where N where var&quot;#s167&quot;&lt;:GeometryBasics.Polygon, GeometryBasics.MultiPolygon}}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(PB, Union{Array{&lt;:Polygon}, MultiPolygon})</code></pre><p>Takes an input <code>Array{Polygon}</code> or a <code>MultiPolygon</code> and decomposes it to points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L328-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an <code>AbstractMatrix</code>, converts the dimesions <code>n</code> and <code>m</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code> and <code>m</code>, plus the original matrix in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L343-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,IntervalSets.Interval{:closed,:closed,T} where T,IntervalSets.Interval{:closed,:closed,T} where T,AbstractArray{T,2} where T}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,IntervalSets.Interval{:closed,:closed,T} where T,IntervalSets.Interval{:closed,:closed,T} where T,AbstractArray{T,2} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x, y, z)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes 2 ClosedIntervals&#39;s <code>x</code>, <code>y</code>, and an AbstractMatrix <code>z</code>, and converts the closed range to linspaces with size(z, 1/2) <code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L195-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,Union{AbstractArray{var&quot;#s81&quot;,1}, AbstractArray{var&quot;#s81&quot;,2}} where var&quot;#s81&quot;&lt;:Number,Union{AbstractArray{var&quot;#s80&quot;,1}, AbstractArray{var&quot;#s80&quot;,2}} where var&quot;#s80&quot;&lt;:Number,AbstractArray{var&quot;#s79&quot;,2} where var&quot;#s79&quot;&lt;:Union{Number, Colorant}}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.SurfaceLike,Union{AbstractArray{var&quot;#s81&quot;,1}, AbstractArray{var&quot;#s81&quot;,2}} where var&quot;#s81&quot;&lt;:Number,Union{AbstractArray{var&quot;#s80&quot;,1}, AbstractArray{var&quot;#s80&quot;,2}} where var&quot;#s80&quot;&lt;:Number,AbstractArray{var&quot;#s79&quot;,2} where var&quot;#s79&quot;&lt;:Union{Number, Colorant}}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x::VecOrMat, y::VecOrMat, z::Matrix)</code></pre><p>Takes 3 <code>AbstractMatrix</code> <code>x</code>, <code>y</code>, and <code>z</code>, converts them to <code>Float32</code> and outputs them in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L252-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Function}" href="#AbstractPlotting.convert_arguments-Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,Function}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes <code>AbstractVector</code> <code>x</code>, <code>y</code>, and <code>z</code> and the function <code>f</code>, evaluates <code>f</code> on the volume spanned by <code>x</code>, <code>y</code> and <code>z</code>, and puts <code>x</code>, <code>y</code>, <code>z</code> and <code>f(x,y,z)</code> in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L404-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.mesh,ArgType} where ArgType),AbstractArray,AbstractArray}" href="#AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.mesh,ArgType} where ArgType),AbstractArray,AbstractArray}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(Mesh, vertices, indices)::GLNormalMesh</code></pre><p>Takes <code>vertices</code> and <code>indices</code>, and creates a triangle mesh out of those. See <a href="abstractplotting_api.html#AbstractPlotting.to_vertices-Union{Tuple{AbstractArray{var&quot;#s168&quot;,1} where var&quot;#s168&quot;&lt;:Union{Tuple{T,T,T}, StaticArrays.StaticArray{Tuple{3},T,1}}}, Tuple{T}} where T"><code>to_vertices</code></a> and <a href="abstractplotting_api.html#AbstractPlotting.to_triangles-Tuple{AbstractArray{Int64,1}}"><code>to_triangles</code></a> for more information about accepted types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L582-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.mesh,ArgType} where ArgType),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.mesh,ArgType} where ArgType),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(Mesh, x, y, z, indices)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in <code>indices</code>, which can be integers (every 3 -&gt; one triangle), or GeometryBasics.NgonFace{N, &lt;: Integer}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L482-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.mesh,ArgType} where ArgType),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}" href="#AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.mesh,ArgType} where ArgType),AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number,AbstractArray{T,1} where T&lt;:Number}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(Mesh, x, y, z)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L423-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.mesh,ArgType} where ArgType),AbstractArray{T,1} where T}" href="#AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.mesh,ArgType} where ArgType),AbstractArray{T,1} where T}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh</code></pre><p>Takes an input mesh and a vector <code>xyz</code> representing the vertices of the mesh, and creates indices under the assumption, that each triplet in <code>xyz</code> forms a triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L435-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.text,ArgType} where ArgType),AbstractString}" href="#AbstractPlotting.convert_arguments-Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.text,ArgType} where ArgType),AbstractString}"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(x)::(String)</code></pre><p>Takes an input <code>AbstractString</code> <code>x</code> and converts it to a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{E}, Tuple{A}, Tuple{T}, Tuple{N}, Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.linesegments,ArgType} where ArgType),AbstractArray{E,1}}} where E&lt;:Union{Pair{A,A}, Tuple{A,A}} where A&lt;:Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N" href="#AbstractPlotting.convert_arguments-Union{Tuple{E}, Tuple{A}, Tuple{T}, Tuple{N}, Tuple{Type{var&quot;#s168&quot;} where var&quot;#s168&quot;&lt;:(Combined{AbstractPlotting.linesegments,ArgType} where ArgType),AbstractArray{E,1}}} where E&lt;:Union{Pair{A,A}, Tuple{A,A}} where A&lt;:Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Accepts a Vector of Pair of Points (e.g. <code>[Point(0, 0) =&gt; Point(1, 1), ...]</code>) to encode e.g. linesegments or directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L164-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{N}, Tuple{AbstractPlotting.PointBased,Union{Tuple{Vararg{var&quot;#s168&quot;,N}}, StaticArrays.StaticArray{Tuple{N},var&quot;#s168&quot;,1}} where var&quot;#s168&quot;&lt;:Number}} where N" href="#AbstractPlotting.convert_arguments-Union{Tuple{N}, Tuple{AbstractPlotting.PointBased,Union{Tuple{Vararg{var&quot;#s168&quot;,N}}, StaticArrays.StaticArray{Tuple{N},var&quot;#s168&quot;,1}} where var&quot;#s168&quot;&lt;:Number}} where N"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Wrap a single point or equivalent object in a single-element array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L62-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T1,1},AbstractArray{T2,1},Function}} where T2 where T1" href="#AbstractPlotting.convert_arguments-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractPlotting.SurfaceLike,AbstractArray{T1,1},AbstractArray{T2,1},Function}} where T2 where T1"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x, y, f)::(Vector, Vector, Matrix)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and the function <code>f</code>, and applies <code>f</code> on the grid that <code>x</code> and <code>y</code> span. This is equivalent to <code>f.(x, y&#39;)</code>. <code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L356-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,3}}} where T" href="#AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,3}}} where T"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes 3 <code>AbstractVector</code> <code>x</code>, <code>y</code>, and <code>z</code> and the <code>AbstractMatrix</code> <code>i</code>, and puts everything in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L392-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,3}}} where T" href="#AbstractPlotting.convert_arguments-Union{Tuple{T}, Tuple{AbstractPlotting.VolumeLike,AbstractArray{T,3}}} where T"><code>AbstractPlotting.convert_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an array of <code>{T, 3} where T</code>, converts the dimesions <code>n</code>, <code>m</code> and <code>k</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code>, <code>m</code> and <code>k</code>, plus the original array in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L376-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute" href="#AbstractPlotting.convert_attribute"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Tuple(A, B) or Pair{A, B} with any object that <a href="abstractplotting_api.html#AbstractPlotting.to_color-Tuple{Any}"><code>to_color</code></a> accepts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L954-L956">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute" href="#AbstractPlotting.convert_attribute"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><p>A Symbol/String naming the gradient. For more on what names are available please see: <code>available_gradients()</code>. For now, we support gradients from <code>PlotUtils</code> natively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L971-L974">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute" href="#AbstractPlotting.convert_attribute"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_colormap(b, x)</code></pre><p>An <code>AbstractVector{T}</code> with any object that <a href="abstractplotting_api.html#AbstractPlotting.to_color-Tuple{Any}"><code>to_color</code></a> accepts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L942-L946">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:linestyle}}" href="#AbstractPlotting.convert_attribute-Tuple{AbstractArray{T,1} where T,AbstractPlotting.Key{:linestyle}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`AbstractVector{&lt;:AbstractFloat}` for denoting sequences of fill/nofill. e.g.</code></pre><p>[0.5, 0.8, 1.2] will result in 0.5 filled, 0.3 unfilled, 0.4 filled. 1.0 unit is one linewidth!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L704-L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Any,AbstractPlotting.Key{:algorithm}}" href="#AbstractPlotting.convert_attribute-Tuple{Any,AbstractPlotting.Key{:algorithm}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_volume_algorithm(b, x)</code></pre><p>Enum values: <code>IsoValue</code> <code>Absorption</code> <code>MaximumIntensityProjection</code> <code>AbsorptionRGBA</code> <code>AdditiveRGBA</code> <code>IndexedAbsorptionRGBA</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1004-L1008">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Quaternion,AbstractPlotting.Key{:rotation}}" href="#AbstractPlotting.convert_attribute-Tuple{Quaternion,AbstractPlotting.Key{:rotation}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotation accepts:
to_rotation(b, quaternion)
to_rotation(b, tuple_float)
to_rotation(b, vec4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L862-L867">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Tuple{Symbol,Symbol},AbstractPlotting.Key{:align}}" href="#AbstractPlotting.convert_attribute-Tuple{Tuple{Symbol,Symbol},AbstractPlotting.Key{:align}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Text align, e.g.:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L817-L819">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{AbstractString, Symbol},AbstractPlotting.Key{:linestyle}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{AbstractString, Symbol},AbstractPlotting.Key{:linestyle}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A `Symbol` equal to `:dash`, `:dot`, `:dashdot`, `:dashdotdot`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L711-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:algorithm}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:algorithm}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Symbol/String: iso, absorption, mip, absorptionrgba, indexedabsorption</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1021-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:font}}" href="#AbstractPlotting.convert_attribute-Tuple{Union{String, Symbol},AbstractPlotting.Key{:font}}"><code>AbstractPlotting.convert_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">font conversion</code></pre><p>a string naming a font, e.g. helvetica</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L824-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.crossbar!-Tuple" href="#AbstractPlotting.crossbar!-Tuple"><code>AbstractPlotting.crossbar!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>crossbar(x, y, ymin, ymax; kwargs...) Draw a crossbar. A crossbar represents a range with a (potentially notched) box. It is most commonly used as part of the <code>boxplot</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: position of the box</li><li><code>y</code>: position of the midline within the box</li><li><code>ymin</code>: lower limit of the box</li><li><code>ymax</code>: upper limit of the box</li></ul><p><strong>Keywords</strong></p><ul><li><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</li><li><code>width=0.8</code>: width of the box</li><li><code>show_notch=false</code>: draw the notch</li><li><code>notchmin=automatic</code>: lower limit of the notch</li><li><code>notchmax=automatic</code>: upper limit of the notch</li><li><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</li><li><code>show_midline=true</code>: show midline</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.crossbar-Tuple" href="#AbstractPlotting.crossbar-Tuple"><code>AbstractPlotting.crossbar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>crossbar(x, y, ymin, ymax; kwargs...) Draw a crossbar. A crossbar represents a range with a (potentially notched) box. It is most commonly used as part of the <code>boxplot</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: position of the box</li><li><code>y</code>: position of the midline within the box</li><li><code>ymin</code>: lower limit of the box</li><li><code>ymax</code>: upper limit of the box</li></ul><p><strong>Keywords</strong></p><ul><li><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</li><li><code>width=0.8</code>: width of the box</li><li><code>show_notch=false</code>: draw the notch</li><li><code>notchmin=automatic</code>: lower limit of the notch</li><li><code>notchmax=automatic</code>: upper limit of the notch</li><li><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</li><li><code>show_midline=true</code>: show midline</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.density!-Tuple" href="#AbstractPlotting.density!-Tuple"><code>AbstractPlotting.density!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">density(values; npoints = 200, offset = 0.0, direction = :x)</code></pre><p>Plot a kernel density estimate of <code>values</code>. <code>npoints</code> controls the resolution of the estimate, the baseline can be shifted with <code>offset</code> and the <code>direction</code> set to :x or :y. <code>bandwidth</code> and <code>boundary</code> are determined automatically by default. </p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.density!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.density-Tuple" href="#AbstractPlotting.density-Tuple"><code>AbstractPlotting.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">density(values; npoints = 200, offset = 0.0, direction = :x)</code></pre><p>Plot a kernel density estimate of <code>values</code>. <code>npoints</code> controls the resolution of the estimate, the baseline can be shifted with <code>offset</code> and the <code>direction</code> set to :x or :y. <code>bandwidth</code> and <code>boundary</code> are determined automatically by default. </p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.density,T} where T</code> are: </p><pre><code class="nohighlight">  bandwidth     AbstractPlotting.Automatic()
  boundary      AbstractPlotting.Automatic()
  color         :gray85
  direction     :x
  npoints       200
  offset        0.0
  strokearound  false
  strokecolor   :black
  strokewidth   1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.errorbars!-Tuple" href="#AbstractPlotting.errorbars!-Tuple"><code>AbstractPlotting.errorbars!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">errorbars(x, y, error_both; kwargs...)
errorbars(x, y, error_low, error_high; kwargs...)
errorbars(x, y, error_low_high; kwargs...)

errorbars(xy, error_both; kwargs...)
errorbars(xy, error_low, error_high; kwargs...)
errorbars(xy, error_low_high; kwargs...)

errorbars(xy_error_both; kwargs...)
errorbars(xy_error_low_high; kwargs...)</code></pre><p>Plots errorbars at xy positions, extending by errors in the given <code>direction</code>.</p><p>If you want to plot intervals from low to high values instead of relative errors, use <code>rangebars</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.errorbars!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.errorbars-Tuple" href="#AbstractPlotting.errorbars-Tuple"><code>AbstractPlotting.errorbars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">errorbars(x, y, error_both; kwargs...)
errorbars(x, y, error_low, error_high; kwargs...)
errorbars(x, y, error_low_high; kwargs...)

errorbars(xy, error_both; kwargs...)
errorbars(xy, error_low, error_high; kwargs...)
errorbars(xy, error_low_high; kwargs...)

errorbars(xy_error_both; kwargs...)
errorbars(xy_error_low_high; kwargs...)</code></pre><p>Plots errorbars at xy positions, extending by errors in the given <code>direction</code>.</p><p>If you want to plot intervals from low to high values instead of relative errors, use <code>rangebars</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.errorbars,T} where T</code> are: </p><pre><code class="nohighlight">  color         :black
  colormap      :viridis
  direction     :y
  linewidth     1
  visible       true
  whiskerwidth  10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.fill_between!-Tuple{Any,Any,Any}" href="#AbstractPlotting.fill_between!-Tuple{Any,Any,Any}"><code>AbstractPlotting.fill_between!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill_between!(x, y1, y2; where = nothing, scene = current_scene(), kw_args...)</code></pre><p>fill the section between 2 lines with the condition <code>where</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/basic_recipes/band.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.force_update!-Tuple{}" href="#AbstractPlotting.force_update!-Tuple{}"><code>AbstractPlotting.force_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Forces the scene to be re-rendered</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L437-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.heatmap!-Tuple" href="#AbstractPlotting.heatmap!-Tuple"><code>AbstractPlotting.heatmap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">heatmap(x, y, values)
heatmap(values)</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.heatmap!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.heatmap-Tuple" href="#AbstractPlotting.heatmap-Tuple"><code>AbstractPlotting.heatmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">heatmap(x, y, values)
heatmap(values)</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.heatmap,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  highclip        &quot;nothing&quot;
  interpolate     false
  levels          1
  lightposition   :eyeposition
  linewidth       0.0
  lowclip         &quot;nothing&quot;
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.help-Tuple{Any}" href="#AbstractPlotting.help-Tuple{Any}"><code>AbstractPlotting.help</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">help(func[; extended = false])</code></pre><p>Welcome to the main help function of <code>Makie.jl</code> / <code>AbstractPlotting.jl</code>.</p><p>For help on a specific function&#39;s arguments, type <code>help_arguments(function_name)</code>.</p><p>For help on a specific function&#39;s attributes, type <code>help_attributes(plot_Type)</code>.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/documentation/documentation.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.help_arguments-Tuple{Any}" href="#AbstractPlotting.help_arguments-Tuple{Any}"><code>AbstractPlotting.help_arguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">help_arguments([io], func)</code></pre><p>Returns a list of signatures for function <code>func</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/documentation/documentation.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.help_attributes-Tuple{Any}" href="#AbstractPlotting.help_attributes-Tuple{Any}"><code>AbstractPlotting.help_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">help_attributes([io], Union{PlotType, PlotFunction}; extended = false)</code></pre><p>Returns a list of attributes for the plot type <code>Typ</code>. The attributes returned extend those attributes found in the <code>default_theme</code>.</p><p>Use the optional keyword argument <code>extended</code> (default = <code>false</code>) to show in addition the default values of each attribute. usage:</p><pre><code class="language-example">&gt;help_attributes(scatter)
    alpha
    color
    colormap
    colorrange
    distancefield
    glowcolor
    glowwidth
    linewidth
    marker
    marker_offset
    markersize
    overdraw
    rotations
    strokecolor
    strokewidth
    transform_marker
    transparency
    uv_offset_width
    visible</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/documentation/documentation.jl#L73-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.hist!-Tuple" href="#AbstractPlotting.hist!-Tuple"><code>AbstractPlotting.hist!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hist(values; bins = 15, normalization = :none)</code></pre><p>Plot a histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>. Possible values are:</p><ul><li><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.</li><li><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (<code>h.isdensity == 1</code>).</li><li><code>:probability</code>: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.</li><li><code>:none</code>: Do not normalize.</li></ul><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.hist!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.hist-Tuple" href="#AbstractPlotting.hist-Tuple"><code>AbstractPlotting.hist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hist(values; bins = 15, normalization = :none)</code></pre><p>Plot a histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>. Possible values are:</p><ul><li><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.</li><li><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (<code>h.isdensity == 1</code>).</li><li><code>:probability</code>: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.</li><li><code>:none</code>: Do not normalize.</li></ul><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.hist,T} where T</code> are: </p><pre><code class="nohighlight">  bins           15
  normalization  :none</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.hovered_scene-Tuple{}" href="#AbstractPlotting.hovered_scene-Tuple{}"><code>AbstractPlotting.hovered_scene</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hovered_scene()</code></pre><p>Return the <code>scene</code> that the mouse is currently hovering over.</p><p>Properly identifies the scene for a plot with multiple sub-plots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.image!-Tuple" href="#AbstractPlotting.image!-Tuple"><code>AbstractPlotting.image!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image(x, y, image)
image(image)</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.image!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.image-Tuple" href="#AbstractPlotting.image-Tuple"><code>AbstractPlotting.image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image(x, y, image)
image(image)</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.image,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        [:black, :white]
  diffuse         Float32[0.4, 0.4, 0.4]
  highclip        &quot;nothing&quot;
  interpolate     true
  lightposition   :eyeposition
  linewidth       1
  lowclip         &quot;nothing&quot;
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ispressed-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}" href="#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}"><code>AbstractPlotting.ispressed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ispressed(scene, button)</code></pre><p>Returns true if <code>button</code> is pressed in the given <code>scene</code>. The <code>button</code> can be a <code>Keyboard</code> button (e.g. <code>Keyboard.a</code>), a <code>Mouse</code> button (e.g. <code>Mouse.left</code>) or <code>nothing</code>. In the latter case <code>true</code> is always returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/events.jl#L98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ispressed-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Union{Tuple, Array{T,1} where T}}" href="#AbstractPlotting.ispressed-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Union{Tuple, Array{T,1} where T}}"><code>AbstractPlotting.ispressed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ispressed(scene, buttons)</code></pre><p>Returns true if all <code>buttons</code> are pressed in the given <code>scene</code>. <code>buttons</code> can be a <code>Vector</code> or <code>Tuple</code> of <code>Keyboard</code> buttons (e.g. <code>Keyboard.a</code>), <code>Mouse</code> buttons (e.g. <code>Mouse.left</code>) and <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/events.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.lift-Tuple{Any,Observables.AbstractObservable,Vararg{Any,N} where N}" href="#AbstractPlotting.lift-Tuple{Any,Observables.AbstractObservable,Vararg{Any,N} where N}"><code>AbstractPlotting.lift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lift(f, o1::Observables.AbstractObservable, rest...; init = f(to_value(o1), to_value.(rest)...), typ = typeof(init))</code></pre><p>Create a new <code>Observable</code> by applying <code>f</code> to all observables in <code>o1</code> and <code>rest...</code>. By default, the initial value <code>init</code> is determined by the first function evaluation. You can also set <code>typ</code> to control the parametric type of the Observable irrespective of the <code>init</code> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/nodes.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.lines!-Tuple" href="#AbstractPlotting.lines!-Tuple"><code>AbstractPlotting.lines!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lines(positions)
lines(x, y)
lines(x, y, z)</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can separate segments by inserting <code>NaN</code>s.</p></div></div><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.lines!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.lines-Tuple" href="#AbstractPlotting.lines-Tuple"><code>AbstractPlotting.lines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lines(positions)
lines(x, y)
lines(x, y, z)</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can separate segments by inserting <code>NaN</code>s.</p></div></div><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.lines,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  lightposition   :eyeposition
  linestyle       &quot;nothing&quot;
  linewidth       1.0
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.linesegments!-Tuple" href="#AbstractPlotting.linesegments!-Tuple"><code>AbstractPlotting.linesegments!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linesegments(positions)
linesegments(x, y)
linesegments(x, y, z)</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.linesegments!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.linesegments-Tuple" href="#AbstractPlotting.linesegments-Tuple"><code>AbstractPlotting.linesegments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linesegments(positions)
linesegments(x, y)
linesegments(x, y, z)</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.linesegments,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  lightposition   :eyeposition
  linestyle       &quot;nothing&quot;
  linewidth       1.0
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.map_once-Tuple{Any,Observable,Vararg{Observable,N} where N}" href="#AbstractPlotting.map_once-Tuple{Any,Observable,Vararg{Observable,N} where N}"><code>AbstractPlotting.map_once</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">map_once(closure, inputs::Node....)::Node</code></pre><p>Like Reactive.foreach, in the sense that it will be preserved even if no reference is kept. The difference is, that you can call map once multiple times with the same closure and it will close the old result Node and register a new one instead.</p><p>``` function test(s1::Node)     s3 = map<em>once(x-&gt; (println(&quot;1 &quot;, x); x), s1)     s3 = map</em>once(x-&gt; (println(&quot;2 &quot;, x); x), s1)</p><p>end test(Node(1), Node(2))</p><blockquote></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/nodes.jl#L53-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.mesh!-Tuple" href="#AbstractPlotting.mesh!-Tuple"><code>AbstractPlotting.mesh!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mesh(x, y, z)
mesh(mesh_object)
mesh(x, y, z, faces)
mesh(xyz, faces)</code></pre><p>Plots a 3D or 2D mesh.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.mesh!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.mesh-Tuple" href="#AbstractPlotting.mesh-Tuple"><code>AbstractPlotting.mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mesh(x, y, z)
mesh(mesh_object)
mesh(x, y, z, faces)
mesh(xyz, faces)</code></pre><p>Plots a 3D or 2D mesh.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.mesh,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  interpolate     false
  lightposition   :eyeposition
  linewidth       1
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shading         true
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.meshscatter!-Tuple" href="#AbstractPlotting.meshscatter!-Tuple"><code>AbstractPlotting.meshscatter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meshscatter(positions)
meshscatter(x, y)
meshscatter(x, y, z)</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.meshscatter!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.meshscatter-Tuple" href="#AbstractPlotting.meshscatter-Tuple"><code>AbstractPlotting.meshscatter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meshscatter(positions)
meshscatter(x, y)
meshscatter(x, y, z)</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.meshscatter,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  colorrange      AbstractPlotting.Automatic()
  diffuse         Float32[0.4, 0.4, 0.4]
  lightposition   :eyeposition
  linewidth       1
  marker          GeometryBasics.HyperSphere{3,Float32}(Float32[0.0, 0.0, 0.0], 1.0f0)
  markersize      0.1
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  rotations       1.0 + 0.0im + 0.0jm + 0.0km
  shading         true
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.mouse_selection-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}" href="#AbstractPlotting.mouse_selection-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}"><code>AbstractPlotting.mouse_selection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mouse_selection(scene::Scene)</code></pre><p>Returns the plot that is under the current mouse position</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L32-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.mouseover-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Vararg{AbstractPlot,N} where N}" href="#AbstractPlotting.mouseover-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Vararg{AbstractPlot,N} where N}"><code>AbstractPlotting.mouseover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mouseover(scene::SceneLike, plots::AbstractPlot...)</code></pre><p>Returns true if the mouse currently hovers any of <code>plots</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.mouseposition" href="#AbstractPlotting.mouseposition"><code>AbstractPlotting.mouseposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mouseposition(scene = hovered_scene()) -&gt; pos</code></pre><p>Return the current position of the mouse <code>pos</code> in <em>data points</em> of the given <code>scene</code>.</p><p>By default uses the <code>scene</code> that the mouse is currently hovering over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.must_update-Tuple{}" href="#AbstractPlotting.must_update-Tuple{}"><code>AbstractPlotting.must_update</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns whether a scene needs to be updated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L428-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.onpick" href="#AbstractPlotting.onpick"><code>AbstractPlotting.onpick</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">onpick(func, plot)</code></pre><p>Calls <code>func</code> if one clicks on <code>plot</code>.  Implemented by the backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/events.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.onpick-Tuple{Any,Union{AbstractScene, AbstractPlotting.ScenePlot},Vararg{AbstractPlot,N} where N}" href="#AbstractPlotting.onpick-Tuple{Any,Union{AbstractScene, AbstractPlotting.ScenePlot},Vararg{AbstractPlot,N} where N}"><code>AbstractPlotting.onpick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onpick(f, scene::SceneLike, plots::AbstractPlot...)</code></pre><p>Calls <code>f(idx)</code> whenever the mouse is over any of <code>plots</code>. <code>idx</code> is an index, e.g. when over a scatter plot, it will be the index of the hovered element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.pick" href="#AbstractPlotting.pick"><code>AbstractPlotting.pick</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Picks a mouse position.  Implemented by the backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/events.jl#L111-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.pick-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}" href="#AbstractPlotting.pick-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}"><code>AbstractPlotting.pick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pick(scene::Scene, xy::VecLike[, range])</code></pre><p>Return the plot under pixel position xy</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.pick-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Number,Number}" href="#AbstractPlotting.pick-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Number,Number}"><code>AbstractPlotting.pick</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the plot under pixel position x y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L78-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.pie!-Tuple" href="#AbstractPlotting.pie!-Tuple"><code>AbstractPlotting.pie!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pie(fractions; kwargs...)</code></pre><p>Creates a pie chart with the given <code>fractions</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.pie!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.pie-Tuple" href="#AbstractPlotting.pie-Tuple"><code>AbstractPlotting.pie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pie(fractions; kwargs...)</code></pre><p>Creates a pie chart with the given <code>fractions</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.pie,T} where T</code> are: </p><pre><code class="nohighlight">  color           :gray
  inner_radius    0
  normalize       true
  offset          0
  radius          1
  strokecolor     :black
  strokewidth     1
  vertex_per_deg  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.plot!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Union{Type{Any}, Type{var&quot;#s169&quot;} where var&quot;#s169&quot;&lt;:AbstractPlot},Attributes,Vararg{Any,N} where N}" href="#AbstractPlotting.plot!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Union{Type{Any}, Type{var&quot;#s169&quot;} where var&quot;#s169&quot;&lt;:AbstractPlot},Attributes,Vararg{Any,N} where N}"><code>AbstractPlotting.plot!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Main plotting signatures that plot/plot! route to if no Plot Type is given</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L642-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.poly!-Tuple" href="#AbstractPlotting.poly!-Tuple"><code>AbstractPlotting.poly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">poly(vertices, indices; kwargs...)
poly(points; kwargs...)
poly(shape; kwargs...)
poly(mesh; kwargs...)</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryBasics</code>), it will plot <code>decompose(shape)</code>.</p><pre><code class="nohighlight">poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.poly!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.poly-Tuple" href="#AbstractPlotting.poly-Tuple"><code>AbstractPlotting.poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">poly(vertices, indices; kwargs...)
poly(points; kwargs...)
poly(shape; kwargs...)
poly(mesh; kwargs...)</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryBasics</code>), it will plot <code>decompose(shape)</code>.</p><pre><code class="nohighlight">poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.poly,T} where T</code> are: </p><pre><code class="nohighlight">  color         :black
  colormap      :viridis
  colorrange    AbstractPlotting.Automatic()
  linestyle     &quot;nothing&quot;
  overdraw      false
  shading       false
  strokecolor   RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  strokewidth   1.0
  transparency  false
  visible       true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.rangebars!-Tuple" href="#AbstractPlotting.rangebars!-Tuple"><code>AbstractPlotting.rangebars!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rangebars(val, low, high; kwargs...)
rangebars(val, low_high; kwargs...)
rangebars(val_low_high; kwargs...)</code></pre><p>Plots rangebars at <code>val</code> in one dimension, extending from <code>low</code> to <code>high</code> in the other dimension given the chosen <code>direction</code>.</p><p>If you want to plot errors relative to a reference value, use <code>errorbars</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.rangebars!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.rangebars-Tuple" href="#AbstractPlotting.rangebars-Tuple"><code>AbstractPlotting.rangebars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rangebars(val, low, high; kwargs...)
rangebars(val, low_high; kwargs...)
rangebars(val_low_high; kwargs...)</code></pre><p>Plots rangebars at <code>val</code> in one dimension, extending from <code>low</code> to <code>high</code> in the other dimension given the chosen <code>direction</code>.</p><p>If you want to plot errors relative to a reference value, use <code>errorbars</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.rangebars,T} where T</code> are: </p><pre><code class="nohighlight">  color         :black
  colormap      :viridis
  direction     :y
  linewidth     1
  visible       true
  whiskerwidth  10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.record-Tuple{Any,Any,Any}" href="#AbstractPlotting.record-Tuple{Any,Any,Any}"><code>AbstractPlotting.record</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">record(func, scene, path; framerate = 24, compression = 20)
record(func, scene, path, iter;
        framerate = 24, compression = 20, sleep = true)</code></pre><p>The first signature provides <code>func</code> with a VideoStream, which it should call <code>recordframe!(io)</code> on when recording a frame.</p><p>Records the Scene <code>scene</code> after the application of <code>func</code> on it for each element in <code>itr</code> (any iterator).  <code>func</code> must accept an element of <code>itr</code>.</p><p>The animation is then saved to <code>path</code>, with the format determined by <code>path</code>&#39;s extension.  Allowable extensions are:</p><ul><li><code>.mkv</code>  (the default, doesn&#39;t need to convert)</li><li><code>.mp4</code>  (good for Web, most supported format)</li><li><code>.webm</code> (smallest file size)</li><li><code>.gif</code>  (largest file size for the same quality)</li></ul><p><code>.mp4</code> and <code>.mk4</code> are marginally bigger and <code>.gif</code>s are up to 6 times bigger with the same quality!</p><p>The <code>compression</code> argument controls the compression ratio; <code>51</code> is the highest compression, and <code>0</code> is the lowest (lossless).</p><p>When <code>sleep</code> is set to <code>true</code> (the default), AbstractPlotting will display the animation in real-time by sleeping in between frames. Thus, a 24-frame, 24-fps recording would take one second to record.</p><p>When it is set to <code>false</code>, frames are rendered as fast as the backend can render them.  Thus, a 24-frame, 24-fps recording would usually take much less than one second in GLMakie.</p><p>Typical usage patterns would look like:</p><pre><code class="language-julia">record(scene, &quot;video.mp4&quot;, itr) do i
    func(i) # or some other manipulation of the Scene
end</code></pre><p>or, for more tweakability,</p><pre><code class="language-julia">record(scene, &quot;test.gif&quot;) do io
    for i = 1:100
        func!(scene)     # animate scene
        recordframe!(io) # record a new frame
    end
end</code></pre><p>If you want a more tweakable interface, consider using <a href="abstractplotting_api.html#AbstractPlotting.VideoStream-Tuple{Scene}"><code>VideoStream</code></a> and <a href="abstractplotting_api.html#FileIO.save-Tuple{String,Union{Figure, AbstractPlotting.FigureAxisPlot, Scene}}"><code>save</code></a>.</p><p><strong>Extended help</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia">scene = lines(rand(10))
record(scene, &quot;test.gif&quot;) do io
    for i in 1:255
        scene.plots[:color] = Colors.RGB(i/255, (255 - i)/255, 0) # animate scene
        recordframe!(io)
    end
end</code></pre><p>or</p><pre><code class="language-julia">scene = lines(rand(10))
record(scene, &quot;test.gif&quot;, 1:255) do i
    scene.plots[:color] = Colors.RGB(i/255, (255 - i)/255, 0) # animate scene
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L498-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.record_events-Tuple{Any,Scene,String}" href="#AbstractPlotting.record_events-Tuple{Any,Scene,String}"><code>AbstractPlotting.record_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">record_events(f, scene::Scene, path::String)</code></pre><p>Records all window events that happen while executing function <code>f</code> for <code>scene</code> and serializes them to <code>path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L262-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.recordframe!-Tuple{VideoStream}" href="#AbstractPlotting.recordframe!-Tuple{VideoStream}"><code>AbstractPlotting.recordframe!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">recordframe!(io::VideoStream)</code></pre><p>Adds a video frame to the VideoStream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L426-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.replace_automatic!-Tuple{Any,Any,Any}" href="#AbstractPlotting.replace_automatic!-Tuple{Any,Any,Any}"><code>AbstractPlotting.replace_automatic!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Like <code>get!(f, dict, key)</code> but also calls <code>f</code> and replaces <code>key</code> when the corresponding value is nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.replay_events-Tuple{Scene,String}" href="#AbstractPlotting.replay_events-Tuple{Scene,String}"><code>AbstractPlotting.replay_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replay_events(f, scene::Scene, path::String)
replay_events(scene::Scene, path::String)</code></pre><p>Replays the serialized events recorded with <code>record_events</code> in <code>path</code> in <code>scene</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L284-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.rotate!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}" href="#AbstractPlotting.rotate!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}"><code>AbstractPlotting.rotate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate!(scene::Transformable, axis_rot::Quaternion)
rotate!(scene::Transformable, axis_rot::AbstractFloat)
rotate!(scene::Transformable, axis_rot...)</code></pre><p>Apply an absolute rotation to the Scene. Rotations are all internally converted to <code>Quaternion</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/transformation.jl#L132-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.rotate!-Union{Tuple{T}, Tuple{Type{T},AbstractPlotting.Transformable,Vararg{Any,N} where N}} where T" href="#AbstractPlotting.rotate!-Union{Tuple{T}, Tuple{Type{T},AbstractPlotting.Transformable,Vararg{Any,N} where N}} where T"><code>AbstractPlotting.rotate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate!(Accum, scene::Transformable, axis_rot...)</code></pre><p>Apply a relative rotation to the Scene, by multiplying by the current rotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/transformation.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.rotate_cam!-Tuple{Scene,Vararg{Number,N} where N}" href="#AbstractPlotting.rotate_cam!-Tuple{Scene,Vararg{Number,N} where N}"><code>AbstractPlotting.rotate_cam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate_cam!(scene::Scene, theta_v::Number...)
rotate_cam!(scene::Scene, theta_v::VecTypes)</code></pre><p>Rotate the camera of the Scene by the given rotation. Passing <code>theta_v = (α, β, γ)</code> will rotate the camera according to the Euler angles (α, β, γ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera3d.jl#L252-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.scale!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}" href="#AbstractPlotting.scale!-Tuple{AbstractPlotting.Transformable,Vararg{Any,N} where N}"><code>AbstractPlotting.scale!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale!(t::Transformable, x, y)
scale!(t::Transformable, x, y, z)
scale!(t::Transformable, xyz)
scale!(t::Transformable, xyz...)</code></pre><p>Scale the given <code>Transformable</code> (a Scene or Plot) to the given arguments. Can take <code>x, y</code> or <code>x, y, z</code>. This is an absolute scaling, and there is no option to perform relative scaling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/transformation.jl#L99-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.scatter!-Tuple" href="#AbstractPlotting.scatter!-Tuple"><code>AbstractPlotting.scatter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scatter(positions)
scatter(x, y)
scatter(x, y, z)</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.scatter!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.scatter-Tuple" href="#AbstractPlotting.scatter-Tuple"><code>AbstractPlotting.scatter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scatter(positions)
scatter(x, y)
scatter(x, y, z)</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.scatter,T} where T</code> are: </p><pre><code class="nohighlight">  ambient           Float32[0.55, 0.55, 0.55]
  color             :gray65
  colormap          :viridis
  diffuse           Float32[0.4, 0.4, 0.4]
  distancefield     &quot;nothing&quot;
  glowcolor         RGBA{N0f8}(0.0,0.0,0.0,0.0)
  glowwidth         0.0
  lightposition     :eyeposition
  linewidth         1
  marker            GeometryBasics.HyperSphere{2,T} where T
  marker_offset     AbstractPlotting.Automatic()
  markersize        10
  markerspace       Pixel
  nan_color         RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw          false
  rotations         Billboard()
  shininess         32.0f0
  specular          Float32[0.2, 0.2, 0.2]
  ssao              false
  strokecolor       :black
  strokewidth       1.0
  transform_marker  false
  transparency      false
  uv_offset_width   Float32[0.0, 0.0, 0.0, 0.0]
  visible           true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.scatterlines!-Tuple" href="#AbstractPlotting.scatterlines!-Tuple"><code>AbstractPlotting.scatterlines!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>scatter</code> markers and <code>lines</code> between them.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.scatterlines!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.scatterlines-Tuple" href="#AbstractPlotting.scatterlines-Tuple"><code>AbstractPlotting.scatterlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>scatter</code> markers and <code>lines</code> between them.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.scatterlines,T} where T</code> are: </p><pre><code class="nohighlight">  color             :black
  colormap          :viridis
  colorrange        AbstractPlotting.Automatic()
  linestyle         &quot;nothing&quot;
  linewidth         1.0
  marker            GeometryBasics.HyperSphere{2,T} where T
  markercolor       :gray65
  markercolormap    :viridis
  markercolorrange  AbstractPlotting.Automatic()
  markersize        10
  strokecolor       :black
  strokewidth       1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.select_line-Tuple{Any}" href="#AbstractPlotting.select_line-Tuple{Any}"><code>AbstractPlotting.select_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">select_line(scene; kwargs...) -&gt; line</code></pre><p>Interactively select a line (typically an arrow) on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. Return an <strong>observable</strong> whose value corresponds to the selected line on the scene. In addition the function <em>plots</em> the line on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted line disappears.</p><p>The value of the returned line is updated <strong>only</strong> when the user un-clicks and only if the selected line has non-zero length.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L188-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.select_point-Tuple{Any}" href="#AbstractPlotting.select_point-Tuple{Any}"><code>AbstractPlotting.select_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">select_point(scene; kwargs...) -&gt; point</code></pre><p>Interactively select a point on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. Return an <strong>observable</strong> whose value corresponds to the selected point on the scene. In addition the function <em>plots</em> the point on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted point disappears.</p><p>The value of the returned point is updated <strong>only</strong> when the user un-clicks.</p><p>The <code>kwargs...</code> are propagated into <code>scatter!</code> which plots the selected point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L240-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.select_rectangle-Tuple{Any}" href="#AbstractPlotting.select_rectangle-Tuple{Any}"><code>AbstractPlotting.select_rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">select_rectangle(scene; kwargs...) -&gt; rect</code></pre><p>Interactively select a rectangle on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. The function returns an <strong>observable</strong> <code>rect</code> whose value corresponds to the selected rectangle on the scene. In addition the function <em>plots</em> the selected rectangle on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted rectangle disappears.</p><p>The value of the returned observable is updated <strong>only</strong> when the user un-clicks (i.e. when the final value of the rectangle has been decided) and only if the rectangle has area &gt; 0.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L135-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.series!-Tuple" href="#AbstractPlotting.series!-Tuple"><code>AbstractPlotting.series!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Series - ?</p><p>TODO add function signatures TODO add description</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.series!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.series-Tuple" href="#AbstractPlotting.series-Tuple"><code>AbstractPlotting.series</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Series - ?</p><p>TODO add function signatures TODO add description</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.series,T} where T</code> are: </p><pre><code class="nohighlight">  seriescolors  :Set1
  seriestype    :lines</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.set_theme!" href="#AbstractPlotting.set_theme!"><code>AbstractPlotting.set_theme!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_theme(theme; kwargs...)</code></pre><p>Set the global default theme to <code>theme</code> and add / override any attributes given as keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/theming.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.showgradients-Tuple{AbstractArray{Symbol,1}}" href="#AbstractPlotting.showgradients-Tuple{AbstractArray{Symbol,1}}"><code>AbstractPlotting.showgradients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">showgradients(
    cgrads::AbstractVector{Symbol};
    h = 0.0, offset = 0.2, textsize = 0.7,
    resolution = (800, length(cgrads) * 84)
)::Scene</code></pre><p>Plots the given colour gradients arranged as horizontal colourbars. If you change the offsets or the font size, you may need to change the resolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/basic_recipes/convenience_functions.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.spy!-Tuple" href="#AbstractPlotting.spy!-Tuple"><code>AbstractPlotting.spy!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>spy(x::Range, y::Range, z::AbstractSparseArray)</p><p>Visualizes big sparse matrices. Usage:</p><pre><code class="language-julia">N = 200_000
x = sprand(Float64, N, N, (3(10^6)) / (N*N));
spy(x)
# or if you want to specify the range of x and y:
spy(0..1, 0..1, x)</code></pre><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.spy!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.spy-Tuple" href="#AbstractPlotting.spy-Tuple"><code>AbstractPlotting.spy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>spy(x::Range, y::Range, z::AbstractSparseArray)</p><p>Visualizes big sparse matrices. Usage:</p><pre><code class="language-julia">N = 200_000
x = sprand(Float64, N, N, (3(10^6)) / (N*N));
spy(x)
# or if you want to specify the range of x and y:
spy(0..1, 0..1, x)</code></pre><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.spy,T} where T</code> are: </p><pre><code class="nohighlight">  colormap    :viridis
  colorrange  AbstractPlotting.Automatic()
  framecolor  :black
  framesize   1
  marker      AbstractPlotting.Automatic()
  markersize  AbstractPlotting.Automatic()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.stem!-Tuple" href="#AbstractPlotting.stem!-Tuple"><code>AbstractPlotting.stem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stem(xs, ys, [zs]; kwargs...)</code></pre><p>Plots markers at the given positions extending from <code>offset</code> along stem lines.</p><p><code>offset</code> can be a number, in which case it sets y for 2D, and z for 3D stems. It can be a Point2 for 2D plots, as well as a Point3 for 3D plots. It can also be an iterable of any of these at the same length as xs, ys, zs.</p><p>The conversion trait of stem is <code>PointBased</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.stem!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.stem-Tuple" href="#AbstractPlotting.stem-Tuple"><code>AbstractPlotting.stem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stem(xs, ys, [zs]; kwargs...)</code></pre><p>Plots markers at the given positions extending from <code>offset</code> along stem lines.</p><p><code>offset</code> can be a number, in which case it sets y for 2D, and z for 3D stems. It can be a Point2 for 2D plots, as well as a Point3 for 3D plots. It can also be an iterable of any of these at the same length as xs, ys, zs.</p><p>The conversion trait of stem is <code>PointBased</code>.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.stem,T} where T</code> are: </p><pre><code class="nohighlight">  color            :gray65
  colormap         :viridis
  colorrange       AbstractPlotting.Automatic()
  marker           :circle
  markersize       10
  offset           0
  stemcolor        :black
  stemcolormap     :viridis
  stemcolorrange   AbstractPlotting.Automatic()
  stemlinestyle    &quot;nothing&quot;
  stemwidth        1
  strokecolor      :black
  strokewidth      1
  trunkcolor       :black
  trunkcolormap    :viridis
  trunkcolorrange  AbstractPlotting.Automatic()
  trunklinestyle   &quot;nothing&quot;
  trunkwidth       1
  visible          true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.step!-Tuple{AbstractPlotting.FolderStepper}" href="#AbstractPlotting.step!-Tuple{AbstractPlotting.FolderStepper}"><code>AbstractPlotting.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step!(s::Stepper)</code></pre><p>steps through a <code>Makie.Stepper</code> and outputs a file with filename <code>filename-step.jpg</code>. This is useful for generating progressive plot examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.streamplot!-Tuple" href="#AbstractPlotting.streamplot!-Tuple"><code>AbstractPlotting.streamplot!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>streamplot(f::function, xinterval, yinterval; kwargs...)</p><p>f must either accept <code>f(::Point)</code> or <code>f(x::Number, y::Number)</code>. f must return a Point2.</p><p>Example:</p><pre><code class="language-julia">v(x::Point2{T}) where T = Point2f0(x[2], 4*x[1])
streamplot(v, -2..2, -2..2)</code></pre><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.streamplot!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre><p><strong>Implementation</strong></p><p>See the function <a href="abstractplotting_api.html#AbstractPlotting.streamplot_impl-Union{Tuple{T}, Tuple{N}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any,Any}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any,Any,Any}} where T where N"><code>streamplot_impl</code></a> for implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.streamplot-Tuple" href="#AbstractPlotting.streamplot-Tuple"><code>AbstractPlotting.streamplot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>streamplot(f::function, xinterval, yinterval; kwargs...)</p><p>f must either accept <code>f(::Point)</code> or <code>f(x::Number, y::Number)</code>. f must return a Point2.</p><p>Example:</p><pre><code class="language-julia">v(x::Point2{T}) where T = Point2f0(x[2], 4*x[1])
streamplot(v, -2..2, -2..2)</code></pre><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.streamplot,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  arrow_size      0.03
  color           :black
  colormap        :viridis
  density         1.0
  diffuse         Float32[0.4, 0.4, 0.4]
  gridsize        (32, 32, 32)
  lightposition   :eyeposition
  linestyle       &quot;nothing&quot;
  linewidth       1.0
  maxsteps        500
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  stepsize        0.01
  transparency    false
  visible         true</code></pre><p><strong>Implementation</strong></p><p>See the function <a href="abstractplotting_api.html#AbstractPlotting.streamplot_impl-Union{Tuple{T}, Tuple{N}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any,Any}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any,Any,Any}} where T where N"><code>streamplot_impl</code></a> for implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.surface!-Tuple" href="#AbstractPlotting.surface!-Tuple"><code>AbstractPlotting.surface!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surface(x, y, z)</code></pre><p>Plots a surface, where <code>(x, y)</code>  define a grid whose heights are the entries in <code>z</code>. <code>x</code> and <code>y</code> may be <code>Vectors</code> which define a regular grid, <strong>or</strong> <code>Matrices</code> which define an irregular grid.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.surface!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.surface-Tuple" href="#AbstractPlotting.surface-Tuple"><code>AbstractPlotting.surface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surface(x, y, z)</code></pre><p>Plots a surface, where <code>(x, y)</code>  define a grid whose heights are the entries in <code>z</code>. <code>x</code> and <code>y</code> may be <code>Vectors</code> which define a regular grid, <strong>or</strong> <code>Matrices</code> which define an irregular grid.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.surface,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           &quot;nothing&quot;
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  highclip        &quot;nothing&quot;
  invert_normals  false
  lightposition   :eyeposition
  linewidth       1
  lowclip         &quot;nothing&quot;
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shading         true
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.text!-Tuple" href="#AbstractPlotting.text!-Tuple"><code>AbstractPlotting.text!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">text(string)</code></pre><p>Plots a text.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.text!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.text-Tuple" href="#AbstractPlotting.text-Tuple"><code>AbstractPlotting.text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">text(string)</code></pre><p>Plots a text.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.text,T} where T</code> are: </p><pre><code class="nohighlight">  _glyphlayout    &quot;nothing&quot;
  align           (:left, :bottom)
  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  diffuse         Float32[0.4, 0.4, 0.4]
  font            &quot;Dejavu Sans&quot;
  justification   AbstractPlotting.Automatic()
  lightposition   :eyeposition
  lineheight      1.0
  linewidth       1
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  position        Float32[0.0, 0.0]
  rotation        0.0
  shininess       32.0f0
  space           :screen
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  strokecolor     (:black, 0.0)
  strokewidth     0
  textsize        20
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.timeseries!-Tuple" href="#AbstractPlotting.timeseries!-Tuple"><code>AbstractPlotting.timeseries!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">timeseries(x::Node{{Union{Number, Point2}}})</code></pre><p>Plots a sampled signal. Usage:</p><pre><code class="language-julia">signal = Node(1.0)
scene = timeseries(signal)
display(scene)
# @async is optional, but helps to continue evaluating more code
@async while isopen(scene)
    # aquire data from e.g. a sensor:
    data = rand()
    # update the signal
    signal[] = data
    # sleep/ wait for new data/ whatever...
    # It&#39;s important to yield here though, otherwise nothing will be rendered
    sleep(1/30)
end
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.timeseries-Tuple" href="#AbstractPlotting.timeseries-Tuple"><code>AbstractPlotting.timeseries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">timeseries(x::Node{{Union{Number, Point2}}})</code></pre><p>Plots a sampled signal. Usage:</p><pre><code class="language-julia">signal = Node(1.0)
scene = timeseries(signal)
display(scene)
# @async is optional, but helps to continue evaluating more code
@async while isopen(scene)
    # aquire data from e.g. a sensor:
    data = rand()
    # update the signal
    signal[] = data
    # sleep/ wait for new data/ whatever...
    # It&#39;s important to yield here though, otherwise nothing will be rendered
    sleep(1/30)
end
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.title-Tuple{Any,Any}" href="#AbstractPlotting.title-Tuple{Any,Any}"><code>AbstractPlotting.title</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">title(
    [scene=current_scene(), ], string;
    align = (:center, :bottom), textsize = 30, parent = Scene(), formatter = string, kw...
)</code></pre><p>Add a title with content <code>string</code> to <code>scene</code>.  Pass a <code>Function</code> to the <code>formatter</code> kwarg if the value passed to <code>string</code> isn&#39;t actually a String.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/basic_recipes/title.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_color-Tuple{Any}" href="#AbstractPlotting.to_color-Tuple{Any}"><code>AbstractPlotting.to_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_color(color)</code></pre><p>Converts a <code>color</code> symbol (e.g. <code>:blue</code>) to a color RGBA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_colormap-Tuple{Any}" href="#AbstractPlotting.to_colormap-Tuple{Any}"><code>AbstractPlotting.to_colormap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_colormap(cm[, N = 20])</code></pre><p>Converts a colormap <code>cm</code> symbol (e.g. <code>:Spectral</code>) to a colormap RGB array, where <code>N</code> specifies the number of color points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.translate!-Tuple{AbstractPlotting.Transformable,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}" href="#AbstractPlotting.translate!-Tuple{AbstractPlotting.Transformable,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}"><code>AbstractPlotting.translate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate!(scene::Transformable, xyz::VecTypes)
translate!(scene::Transformable, xyz...)</code></pre><p>Apply an absolute translation to the Scene, translating it to <code>x, y, z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/transformation.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.translate!-Union{Tuple{T}, Tuple{Type{T},AbstractPlotting.Transformable,Vararg{Any,N} where N}} where T" href="#AbstractPlotting.translate!-Union{Tuple{T}, Tuple{Type{T},AbstractPlotting.Transformable,Vararg{Any,N} where N}} where T"><code>AbstractPlotting.translate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate!(Accum, scene::Transformable, xyz...)</code></pre><p>Translate the scene relative to its current position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/transformation.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.translate_cam!-Tuple{Scene,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}" href="#AbstractPlotting.translate_cam!-Tuple{Scene,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}"><code>AbstractPlotting.translate_cam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate_cam!(scene::Scene. translation::VecTypes)</code></pre><p>Translate the camera to the given coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera3d.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.update!-Tuple{Scene}" href="#AbstractPlotting.update!-Tuple{Scene}"><code>AbstractPlotting.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`update!(p::Scene)`</code></pre><p>Updates a <code>Scene</code> and all its children. Update will perform the following operations for every scene:</p><pre><code class="language-julia">if !scene.raw[]
    scene.update_limits[] &amp;&amp; update_limits!(scene)
    scene.scale_plot[] &amp;&amp; scale_scene!(scene)
    scene.center[] &amp;&amp; center!(scene)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L271-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.update_cam!" href="#AbstractPlotting.update_cam!"><code>AbstractPlotting.update_cam!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_cam!(scene::Scene, eyeposition, lookat, up = Vec3f0(0, 0, 1))</code></pre><p>Updates the camera&#39;s controls to point to the specified location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera3d.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}" href="#AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot},Any}"><code>AbstractPlotting.update_cam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_cam!(scene::SceneLike, area)</code></pre><p>Updates the camera for the given <code>scene</code> to cover the given <code>area</code> in 2d.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera2d.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}" href="#AbstractPlotting.update_cam!-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}"><code>AbstractPlotting.update_cam!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_cam!(scene::SceneLike)</code></pre><p>Updates the camera for the given <code>scene</code> to cover the limits of the <code>Scene</code>. Useful when using the <code>Node</code> pipeline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera2d.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.update_limits!" href="#AbstractPlotting.update_limits!"><code>AbstractPlotting.update_limits!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_limits!(scene::Scene, new_limits::Rect, padding = Vec3f0(0))</code></pre><p>This function updates the limits of the given <code>Scene</code> according to the given Rect.</p><p>A <code>Rect</code> is a generalization of a rectangle to n dimensions.  It contains two vectors. The first vector defines the origin; the second defines the displacement of the vertices from the origin. This second vector can be thought of in two dimensions as a vector of width (x-axis) and height (y-axis), and in three dimensions as a vector of the width (x-axis), breadth (y-axis), and height (z-axis).</p><p>Such a <code>Rect</code> can be constructed using the <code>FRect</code> or <code>FRect3D</code> functions that are exported by <code>AbstractPlotting.jl</code>.  See their documentation for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L559-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.update_limits!-Tuple{Scene}" href="#AbstractPlotting.update_limits!-Tuple{Scene}"><code>AbstractPlotting.update_limits!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_limits!(scene::Scene, limits::Union{Automatic, Rect} = scene.limits[], padding = scene.padding[])</code></pre><p>This function updates the limits of the <code>Scene</code> passed to it based on its data. If an actual limit is set by the theme or its attributes (scene.limits !== automatic), it will not update the limits. Call update_limits!(scene, automatic) for that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L515-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.volume!-Tuple" href="#AbstractPlotting.volume!-Tuple"><code>AbstractPlotting.volume!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">volume(volume_data)</code></pre><p>Plots a volume. Available algorithms are:</p><ul><li><code>:iso</code> =&gt; IsoValue</li><li><code>:absorption</code> =&gt; Absorption</li><li><code>:mip</code> =&gt; MaximumIntensityProjection</li><li><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</li><li><code>:additive</code> =&gt; AdditiveRGBA</li><li><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</li></ul><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.volume!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.volume-Tuple" href="#AbstractPlotting.volume-Tuple"><code>AbstractPlotting.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">volume(volume_data)</code></pre><p>Plots a volume. Available algorithms are:</p><ul><li><code>:iso</code> =&gt; IsoValue</li><li><code>:absorption</code> =&gt; Absorption</li><li><code>:mip</code> =&gt; MaximumIntensityProjection</li><li><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</li><li><code>:additive</code> =&gt; AdditiveRGBA</li><li><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</li></ul><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.volume,T} where T</code> are: </p><pre><code class="nohighlight">  algorithm       :mip
  ambient         Float32[0.55, 0.55, 0.55]
  color           &quot;nothing&quot;
  colormap        :viridis
  colorrange      (0, 1)
  diffuse         Float32[0.4, 0.4, 0.4]
  isorange        0.05
  isovalue        0.5
  lightposition   :eyeposition
  linewidth       1
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.volumeslices!-Tuple" href="#AbstractPlotting.volumeslices!-Tuple"><code>AbstractPlotting.volumeslices!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>VolumeSlices</p><p>TODO add function signatures TODO add descripton</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.volumeslices!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.volumeslices-Tuple" href="#AbstractPlotting.volumeslices-Tuple"><code>AbstractPlotting.volumeslices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>VolumeSlices</p><p>TODO add function signatures TODO add descripton</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.volumeslices,T} where T</code> are: </p><pre><code class="nohighlight">  alpha       0.1
  colormap    :viridis
  colorrange  &quot;nothing&quot;
  contour     Attributes with 0 entries
  heatmap     Attributes with 0 entries</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.wireframe!-Tuple" href="#AbstractPlotting.wireframe!-Tuple"><code>AbstractPlotting.wireframe!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wireframe(x, y, z)
wireframe(positions)
wireframe(mesh)</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.wireframe!,T} where T</code> are: </p><pre><code class="nohighlight"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.wireframe-Tuple" href="#AbstractPlotting.wireframe-Tuple"><code>AbstractPlotting.wireframe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wireframe(x, y, z)
wireframe(positions)
wireframe(mesh)</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p><p><strong>Attributes</strong></p><p>Available attributes and their defaults for <code>Combined{AbstractPlotting.wireframe,T} where T</code> are: </p><pre><code class="nohighlight">  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  lightposition   :eyeposition
  linestyle       &quot;nothing&quot;
  linewidth       1.0
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/69fcb5745bda8a5588c089f7b65831787cffc366/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.with_theme" href="#AbstractPlotting.with_theme"><code>AbstractPlotting.with_theme</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">with_theme(f, theme = Theme(); kwargs...)</code></pre><p>Calls <code>f</code> with <code>theme</code> temporarily activated. Attributes in <code>theme</code> can be overridden or extended with <code>kwargs</code>. The previous theme is always restored afterwards, no matter if <code>f</code> succeeds or fails.</p><p>Example:</p><pre><code class="language-julia">my_theme = Theme(resolution = (500, 500), color = :red)
with_theme(my_theme, color = :blue, linestyle = :dashed) do
    scatter(randn(100, 2))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/theming.jl#L111-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.xlabel!-Tuple{Any,AbstractString}" href="#AbstractPlotting.xlabel!-Tuple{Any,AbstractString}"><code>AbstractPlotting.xlabel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xlabel!([scene,] xlabel)</code></pre><p>Set the x-axis label for the given Scene. Defaults to using the current Scene.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.xlims!-Tuple{Scene,Tuple{Real,Real}}" href="#AbstractPlotting.xlims!-Tuple{Scene,Tuple{Real,Real}}"><code>AbstractPlotting.xlims!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xlims!(limits::Real...)
xlims!(limits::NTuple{2, Real})
xlims!(scene, limits::Real...)
xlims!(scene, limits::NTuple{2, Real})</code></pre><p>Set the x-limits for the given Scene (defaults to current Scene).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.xticklabels-Tuple{Any}" href="#AbstractPlotting.xticklabels-Tuple{Any}"><code>AbstractPlotting.xticklabels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xticklabels(scene)</code></pre><p>Returns the all the x-axis tick labels. See also <code>ticklabels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.xtickrange-Tuple{Any}" href="#AbstractPlotting.xtickrange-Tuple{Any}"><code>AbstractPlotting.xtickrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xtickrange(scene)</code></pre><p>Returns the tick range along the x-axis. See also <code>tickranges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.xtickrotation!-Tuple{Scene,Any}" href="#AbstractPlotting.xtickrotation!-Tuple{Scene,Any}"><code>AbstractPlotting.xtickrotation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xtickrotation!([scene,] xangle)</code></pre><p>Set the rotation of tick labels along the x-axis. See also <code>tickrotations!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L308-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.xtickrotation-Tuple{Any}" href="#AbstractPlotting.xtickrotation-Tuple{Any}"><code>AbstractPlotting.xtickrotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xtickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the x-axis. See also <code>tickrotations</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L272-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.xticks!" href="#AbstractPlotting.xticks!"><code>AbstractPlotting.xticks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xticks!([scene,]; xtickrange=xtickrange(scene), xticklabels=xticklabel(scene))</code></pre><p>Set the tick labels and range along the x-axes. See also <code>ticks!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ylabel!-Tuple{Any,AbstractString}" href="#AbstractPlotting.ylabel!-Tuple{Any,AbstractString}"><code>AbstractPlotting.ylabel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ylabel!([scene,] ylabel)</code></pre><p>Set the y-axis label for the given Scene. Defaults to using the current Scene.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ylims!-Tuple{Scene,Tuple{Real,Real}}" href="#AbstractPlotting.ylims!-Tuple{Scene,Tuple{Real,Real}}"><code>AbstractPlotting.ylims!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ylims!(limits::Real...)
ylims!(limits::NTuple{2, Real})
ylims!(scene, limits::Real...)
ylims!(scene, limits::NTuple{2, Real})</code></pre><p>Set the y-limits for the given Scene (defaults to current Scene).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L102-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.yticklabels-Tuple{Any}" href="#AbstractPlotting.yticklabels-Tuple{Any}"><code>AbstractPlotting.yticklabels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">yticklabels(scene)</code></pre><p>Returns the all the y-axis tick labels. See also <code>ticklabels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ytickrange-Tuple{Any}" href="#AbstractPlotting.ytickrange-Tuple{Any}"><code>AbstractPlotting.ytickrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ytickrange(scene)</code></pre><p>Returns the tick range along the y-axis. See also <code>tickranges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ytickrotation!-Tuple{Scene,Any}" href="#AbstractPlotting.ytickrotation!-Tuple{Scene,Any}"><code>AbstractPlotting.ytickrotation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ytickrotation!([scene,] yangle)</code></pre><p>Set the rotation of tick labels along the y-axis. See also <code>tickrotations!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ytickrotation-Tuple{Any}" href="#AbstractPlotting.ytickrotation-Tuple{Any}"><code>AbstractPlotting.ytickrotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ytickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the y-axis. See also <code>tickrotations</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.yticks!" href="#AbstractPlotting.yticks!"><code>AbstractPlotting.yticks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yticks!([scene,]; ytickrange=ytickrange(scene), yticklabels=yticklabel(scene))</code></pre><p>Set the tick labels and range along all the y-axis. See also <code>ticks!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.zlabel!-Tuple{Any,AbstractString}" href="#AbstractPlotting.zlabel!-Tuple{Any,AbstractString}"><code>AbstractPlotting.zlabel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zlabel!([scene,] zlabel)</code></pre><p>Set the z-axis label for the given Scene. Defaults to using the current Scene.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The Scene must have an Axis3D.  If not, then this function will error.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.zlims!-Tuple{Scene,Tuple{Real,Real}}" href="#AbstractPlotting.zlims!-Tuple{Scene,Tuple{Real,Real}}"><code>AbstractPlotting.zlims!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zlims!(limits::Real...)
zlims!(limits::NTuple{2, Real})
zlims!(scene, limits::Real...)
zlims!(scene, limits::NTuple{2, Real})</code></pre><p>Set the z-limits for the given Scene (defaults to current Scene).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L112-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.zoom!-Tuple{Any,Any,Any,Bool}" href="#AbstractPlotting.zoom!-Tuple{Any,Any,Any,Bool}"><code>AbstractPlotting.zoom!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zoom!(scene, point, zoom_step, shift_lookat::Bool)</code></pre><p>Zooms the camera of <code>scene</code> in towards <code>point</code> by a factor of <code>zoom_step</code>. A positive <code>zoom_step</code> zooms in while a negative <code>zoom_step</code> zooms out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera3d.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.zticklabels-Tuple{Any}" href="#AbstractPlotting.zticklabels-Tuple{Any}"><code>AbstractPlotting.zticklabels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zticklabels(scene)</code></pre><p>Returns the all the z-axis tick labels. See also <code>ticklabels</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ztickrange-Tuple{Any}" href="#AbstractPlotting.ztickrange-Tuple{Any}"><code>AbstractPlotting.ztickrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ztickrange(scene)</code></pre><p>Returns the tick range along the z-axis. See also <code>tickranges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ztickrotation!-Tuple{Scene,Any}" href="#AbstractPlotting.ztickrotation!-Tuple{Scene,Any}"><code>AbstractPlotting.ztickrotation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ztickrotation!([scene,] zangle)</code></pre><p>Set the rotation of tick labels along the z-axis. See also <code>tickrotations!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ztickrotation-Tuple{Any}" href="#AbstractPlotting.ztickrotation-Tuple{Any}"><code>AbstractPlotting.ztickrotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ztickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the z-axis. See also <code>tickrotations</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.zticks!" href="#AbstractPlotting.zticks!"><code>AbstractPlotting.zticks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">zticks!([scene,]; ztickranges=ztickrange(scene), zticklabels=zticklabel(scene))</code></pre><p>Set the tick labels and range along all z-axis. See also <code>ticks!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FileIO.save-Tuple{String,Union{Figure, AbstractPlotting.FigureAxisPlot, Scene}}" href="#FileIO.save-Tuple{String,Union{Figure, AbstractPlotting.FigureAxisPlot, Scene}}"><code>FileIO.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FileIO.save(filename, scene; resolution = size(scene), pt_per_unit = 1.0, px_per_unit = 1.0)</code></pre><p>Save a <code>Scene</code> with the specified filename and format.</p><p><strong>Supported Formats</strong></p><ul><li><code>GLMakie</code>: <code>.png</code>, <code>.jpeg</code>, and <code>.bmp</code></li><li><code>CairoMakie</code>: <code>.svg</code>, <code>.pdf</code>, <code>.png</code>, and <code>.jpeg</code></li><li><code>WGLMakie</code>: <code>.png</code></li></ul><p><strong>Supported Keyword Arguments</strong></p><p><strong>All Backends</strong></p><ul><li><code>resolution</code>: <code>(width::Int, height::Int)</code> of the scene in dimensionless units (equivalent to <code>px</code> for GLMakie and WGLMakie).</li></ul><p><strong>CairoMakie</strong></p><ul><li><code>pt_per_unit</code>: The size of one scene unit in <code>pt</code> when exporting to a vector format.</li><li><code>px_per_unit</code>: The size of one scene unit in <code>px</code> when exporting to a bitmap format. This provides a mechanism to export the same scene with higher or lower resolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L206-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FileIO.save-Tuple{String,VideoStream}" href="#FileIO.save-Tuple{String,VideoStream}"><code>FileIO.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save(path::String, io::VideoStream; framerate = 24, compression = 20)</code></pre><p>Flushes the video stream and converts the file to the extension found in <code>path</code>, which can be one of the following:</p><ul><li><code>.mkv</code>  (the default, doesn&#39;t need to convert)</li><li><code>.mp4</code>  (good for Web, most supported format)</li><li><code>.webm</code> (smallest file size)</li><li><code>.gif</code>  (largest file size for the same quality)</li></ul><p><code>.mp4</code> and <code>.mk4</code> are marginally bigger and <code>.gif</code>s are up to 6 times bigger with the same quality!</p><p>The <code>compression</code> argument controls the compression ratio; <code>51</code> is the highest compression, and <code>0</code> is the lowest (lossless).</p><p>See the docs of <a href="abstractplotting_api.html#AbstractPlotting.VideoStream-Tuple{Scene}"><code>VideoStream</code></a> for how to create a VideoStream. If you want a simpler interface, consider using <a href="abstractplotting_api.html#AbstractPlotting.record-Tuple{Any,Any,Any}"><code>record</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L445-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Observables.on-Tuple{Any,Camera,Vararg{Observable,N} where N}" href="#Observables.on-Tuple{Any,Camera,Vararg{Observable,N} where N}"><code>Observables.on</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">on(f, c::Camera, nodes::Node...)</code></pre><p>When mapping over nodes for the camera, we store them in the <code>steering_node</code> vector, to make it easier to disconnect the camera steering signals later!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.@extract-Tuple{Any,Any}" href="#AbstractPlotting.@extract-Tuple{Any,Any}"><code>AbstractPlotting.@extract</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>usage @exctract scene (a, b, c, d)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L86-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.@extractvalue-Tuple{Any,Any}" href="#AbstractPlotting.@extractvalue-Tuple{Any,Any}"><code>AbstractPlotting.@extractvalue</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>usage @extractvalue scene (a, b, c, d) will become:</p><pre><code class="language-example">begin
    a = to_value(scene[:a])
    b = to_value(scene[:b])
    c = to_value(scene[:c])
    (a, b, c)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L117-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.@get_attribute-Tuple{Any,Any}" href="#AbstractPlotting.@get_attribute-Tuple{Any,Any}"><code>AbstractPlotting.@get_attribute</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@get_attribute scene (a, b, c, d)</code></pre><p>This will extract attribute <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> from <code>scene</code> and apply the correct attribute conversions + will extract the value if it&#39;s a signal. It will make those attributes available as variables and return them as a tuple. So the above is equal to: will become:</p><pre><code class="language-example">begin
    a = get_attribute(scene, :a)
    b = get_attribute(scene, :b)
    c = get_attribute(scene, :c)
    (a, b, c)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L93-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.@lift-Tuple{Any}" href="#AbstractPlotting.@lift-Tuple{Any}"><code>AbstractPlotting.@lift</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Replaces an expression with lift(argtuple -&gt; expression, args...), where args are all expressions inside the main one that begin with $.</p><p><strong>Example:</strong></p><p>x = Node(rand(100)) y = Node(rand(100))</p><p><strong>before</strong></p><p>z = lift((x, y) -&gt; x .+ y, x, y)</p><p><strong>after</strong></p><p>z = @lift(x .+ y)</p><p>You can also use parentheses around an expression if that expression evaluates to a node.</p><pre><code class="language-julia">nt = (x = Node(1), y = Node(2))
@lift($(nt.x) + $(nt.y))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/liftmacro.jl#L46-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.@recipe-Tuple{Any,Symbol,Vararg{Symbol,N} where N}" href="#AbstractPlotting.@recipe-Tuple{Any,Symbol,Vararg{Symbol,N} where N}"><code>AbstractPlotting.@recipe</code></a> — <span class="docstring-category">Macro</span></header><section><div><p><strong>Plot Recipes in <code>AbstractPlotting</code></strong></p><p>There&#39;s two types of recipes. <em>Type recipes</em> define a simple mapping from a user defined type to an existing plot type. <em>Full recipes</em> can customize the theme and define a custom plotting function.</p><p><strong>Type recipes</strong></p><p>Type recipe are really simple and just overload the argument conversion pipeline. This can be done for all plot types or for a subset of plot types:</p><pre><code class="nohighlight"># All plot types
convert_arguments(P::Type{&lt;:AbstractPlot}, x::MyType) = convert_arguments(P, rand(10, 10))
# Only for scatter plots
convert_arguments(P::Type{&lt;:Scatter}, x::MyType) = convert_arguments(P, rand(10, 10))</code></pre><p>Optionally you may define the default plot type so that <code>plot(x::MyType)</code> will use this:</p><pre><code class="nohighlight">plottype(::MyType) = Surface</code></pre><p><strong>Full recipes with the <code>@recipe</code> macro</strong></p><p>A full recipe for <code>MyPlot</code> comes in two parts. First is the plot type name, arguments and theme definition which are defined using the <code>@recipe</code> macro. Second is a custom <code>plot!</code> for <code>MyPlot</code>, implemented in terms of the atomic plotting functions.</p><p>We use an example to show how this works:</p><pre><code class="nohighlight"># arguments (x, y, z) &amp;&amp; theme are optional
@recipe(MyPlot, x, y, z) do scene
    Attributes(
        plot_color =&gt; :red
    )
end</code></pre><p>This macro expands to several things. Firstly a type definition:</p><pre><code class="nohighlight">const MyPlot{ArgTypes} = Combined{myplot, ArgTypes}</code></pre><p>The type parameter of <code>Combined</code> contains the function instead of e.g. a symbol. This way the mapping from <code>MyPlot</code> to <code>myplot</code> is safer and simpler. (The downside is we always need a function <code>myplot</code> - TODO: is this a problem?)</p><p>The following signatures are defined to make <code>MyPlot</code> nice to use:</p><pre><code class="nohighlight">myplot(args...; kw_args...) = ...
myplot!(scene, args...; kw_args...) = ...
myplot(kw_args::Dict, args...) = ...
myplot!(scene, kw_args::Dict, args...) = ...
#etc (not 100% settled what signatures there will be)</code></pre><p>A specialization of <code>argument_names</code> is emitted if you have an argument list <code>(x,y,z)</code> provided to the recipe macro:</p><pre><code class="nohighlight">argument_names(::Type{&lt;: MyPlot}) = (:x, :y, :z)</code></pre><p>This is optional but it will allow the use of <code>plot_object[:x]</code> to fetch the first argument from the call <code>plot_object = myplot(rand(10), rand(10), rand(10))</code>, for example. Alternatively you can always fetch the <code>i</code>th argument using <code>plot_object[i]</code>, and if you leave out the <code>(x,y,z)</code>, the default version of <code>argument_names</code> will provide <code>plot_object[:arg1]</code> etc.</p><p>The theme given in the body of the <code>@recipe</code> invocation is inserted into a specialization of <code>default_theme</code> which inserts the theme into any scene that plots <code>MyPlot</code>:</p><pre><code class="nohighlight">function default_theme(scene, ::MyPlot)
    Attributes(
        plot_color =&gt; :red
    )
end</code></pre><p>As the second part of defining <code>MyPlot</code>, you should implement the actual plotting of the <code>MyPlot</code> object by specializing <code>plot!</code>:</p><pre><code class="nohighlight">function plot!(plot::MyPlot)
    # normal plotting code, building on any previously defined recipes
    # or atomic plotting operations, and adding to the combined `plot`:
    lines!(plot, rand(10), color = plot[:plot_color])
    plot!(plot, plot[:x], plot[:y])
    plot
end</code></pre><p>It&#39;s possible to add specializations here, depending on the argument <em>types</em> supplied to <code>myplot</code>. For example, to specialize the behavior of <code>myplot(a)</code> when <code>a</code> is a 3D array of floating point numbers:</p><pre><code class="nohighlight">const MyVolume = MyPlot{Tuple{&lt;:AbstractArray{&lt;: AbstractFloat, 3}}}
argument_names(::Type{&lt;: MyVolume}) = (:volume,) # again, optional
function plot!(plot::MyVolume)
    # plot a volume with a colormap going from fully transparent to plot_color
    volume!(plot, plot[:volume], colormap = :transparent =&gt; plot[:plot_color])
    plot
end</code></pre><p>The docstring given to the recipe will be transferred to the functions it generates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/recipes.jl#L22-L123">source</a></section></article><h2 id="Unexported"><a class="docs-heading-anchor" href="#Unexported">Unexported</a><a id="Unexported-1"></a><a class="docs-heading-anchor-permalink" href="#Unexported" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.automatic" href="#AbstractPlotting.automatic"><code>AbstractPlotting.automatic</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Singleton instance to indicate that an attribute will get calculated automatically</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/types.jl#L169-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.current_backend" href="#AbstractPlotting.current_backend"><code>AbstractPlotting.current_backend</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Current backend</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.AbstractPattern" href="#AbstractPlotting.AbstractPattern"><code>AbstractPlotting.AbstractPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPattern{T} &lt;: AbstractArray{T, 2}</code></pre><p><code>AbstractPatterns</code> are image-like array types which can be used to color plottable objects. There are currently two subtypes: <code>LinePattern</code> and <code>ImagePattern</code>. Any abstract pattern must implement the <code>to_image(pat)</code> function, which must return a <code>Matrix{&lt;: AbstractRGB}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/patterns.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Automatic" href="#AbstractPlotting.Automatic"><code>AbstractPlotting.Automatic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type to indicate that an attribute will get calculated automatically</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/types.jl#L164-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ColorSampler" href="#AbstractPlotting.ColorSampler"><code>AbstractPlotting.ColorSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A colorsampler maps numnber values from a certain range to values of a colormap</p><pre><code class="nohighlight">x = ColorSampler(colormap, (0.0, 1.0))
x[0.5] # returns color at half point of colormap</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L265-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.DeviceIndependentPixel" href="#AbstractPlotting.DeviceIndependentPixel"><code>AbstractPlotting.DeviceIndependentPixel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>https://en.wikipedia.org/wiki/Device-independent_pixel A device-independent pixel (also: density-independent pixel, dip, dp) is a physical unit of measurement based on a coordinate system held by a computer and represents an abstraction of a pixel for use by an application that an underlying system then converts to physical pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/units.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.FastPixel" href="#AbstractPlotting.FastPixel"><code>AbstractPlotting.FastPixel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FastPixel()</code></pre><p>Use</p><pre><code class="language-julia">scatter(..., marker=FastPixel())</code></pre><p>For significant faster plotting times for large amount of points. Note, that this will draw markers always as 1 pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1075-L1086">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.FolderStepper" href="#AbstractPlotting.FolderStepper"><code>AbstractPlotting.FolderStepper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Stepper(scene, path; format = :jpg)</code></pre><p>Creates a Stepper for generating progressive plot examples.</p><p>Each &quot;step&quot; is saved as a separate file in the folder pointed to by <code>path</code>, and the format is customizable by <code>format</code>, which can be any output type your backend supports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Glyphlayout" href="#AbstractPlotting.Glyphlayout"><code>AbstractPlotting.Glyphlayout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Glyphlayout</code></pre><p>Stores information about the glyphs in a string that had a layout calculated for them. <code>origins</code> are the character origins relative to the layout&#39;s [0,0] point (the alignment) and rotation anchor). <code>bboxes</code> are the glyph bounding boxes relative to the glyphs&#39; own origins. <code>hadvances</code> are the horizontal advance values, those are mostly needed for interactive purposes, for example to display a cursor at the right offset from a space character.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/layouting.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.LinePattern-Tuple{}" href="#AbstractPlotting.LinePattern-Tuple{}"><code>AbstractPlotting.LinePattern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LinePattern([; kwargs...])</code></pre><p>Creates a <code>LinePattern</code> for the given keyword arguments:</p><ul><li><code>direction</code>: The direction of the line.</li><li><code>width</code>: The width of the line</li><li><code>tilesize</code>: The size of the image on which the line is drawn. This should be</li></ul><p>compatible with the direction.</p><ul><li><code>shift</code>: Sets the starting point for the line.</li><li><code>linecolor</code>: The color with which the line is replaced.</li><li><code>background_color</code>:: The background color.</li></ul><p>Multiple <code>direction</code>s, <code>width</code>s and <code>shift</code>s can also be given to create more complex patterns, e.g. a cross-hatching pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/patterns.jl#L46-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Millimeter" href="#AbstractPlotting.Millimeter"><code>AbstractPlotting.Millimeter</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Millimeter on screen. This unit respects the dimension and pixel density of the screen to represent millimeters on the screen. This is the must use unit for layouting, that needs to look the same on all kind of screens. Similar as with the <a href="abstractplotting_api.html#AbstractPlotting.Pixel"><code>Pixel</code></a> unit, a camera can change the actually displayed dimensions of any object using the millimeter unit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/units.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ObservableAttributes" href="#AbstractPlotting.ObservableAttributes"><code>AbstractPlotting.ObservableAttributes</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Main structure for holding attributes in e.g. plots!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/attributes.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.OnFieldUpdate" href="#AbstractPlotting.OnFieldUpdate"><code>AbstractPlotting.OnFieldUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><p>attributes.attribute returns an observable. Since we don&#39;t actually convert all values to Observables anymore, we&#39;ll need to create new Observables on getproperty. With OnFieldUpdate, we can do that lazily, store them in <code>listeners(onchange(obs))</code>, and only create a new one for fields that aren&#39;t in listeners yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/attributes.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Transformable" href="#AbstractPlotting.Transformable"><code>AbstractPlotting.Transformable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Transformable</code></pre><p>This is a bit of a weird name, but all scenes and plots are transformable, so that&#39;s what they all have in common. This might be better expressed as traits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/dictlike.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.Plot-Union{Tuple{Vararg{Any,N}}, Tuple{N}} where N" href="#AbstractPlotting.Plot-Union{Tuple{Vararg{Any,N}}, Tuple{N}} where N"><code>AbstractPlotting.Plot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the Combined type that represents the signature of <code>args</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L580-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting._group_polys-Tuple{Any,Any}" href="#AbstractPlotting._group_polys-Tuple{Any,Any}"><code>AbstractPlotting._group_polys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_group_polys(points, ids)</code></pre><p>Given a vector of polygon vertices, and one vector of group indices, which are assumed to be returned from the isoband algorithm, return a vector of groups, where each group has one outer polygon and zero or more inner polygons which are holes in the outer polygon. It is possible that one group has multiple outer polygons with multiple holes each.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/basic_recipes/contourf.jl#L152-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.apply_convert!-Tuple{Any,Attributes,Tuple}" href="#AbstractPlotting.apply_convert!-Tuple{Any,Attributes,Tuple}"><code>AbstractPlotting.apply_convert!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>apply for return type     (args...,)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L440-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.apply_convert!-Union{Tuple{S}, Tuple{Any,Attributes,PlotSpec{S}}} where S" href="#AbstractPlotting.apply_convert!-Union{Tuple{S}, Tuple{Any,Attributes,PlotSpec{S}}} where S"><code>AbstractPlotting.apply_convert!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>apply for return type PlotSpec</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L448-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.apply_scaling-Tuple{Number,AbstractPlotting.Scaling{typeof(identity),Nothing}}" href="#AbstractPlotting.apply_scaling-Tuple{Number,AbstractPlotting.Scaling{typeof(identity),Nothing}}"><code>AbstractPlotting.apply_scaling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_scaling(value::Number, scaling::Scaling)</code></pre><p>Scales a number to the range 0..1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/colorsampler.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.apply_transform-Tuple{typeof(identity),Number}" href="#AbstractPlotting.apply_transform-Tuple{typeof(identity),Number}"><code>AbstractPlotting.apply_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_transform(f, data)</code></pre><p>Apply the data transform func to the data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/transformation.jl#L208-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.argument_names-Tuple{P} where P&lt;:AbstractPlot" href="#AbstractPlotting.argument_names-Tuple{P} where P&lt;:AbstractPlot"><code>AbstractPlotting.argument_names</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Each argument can be named for a certain plot type <code>P</code>. Falls back to <code>arg1</code>, <code>arg2</code>, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L322-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.atomic_limits-Union{Tuple{Union{Combined{AbstractPlotting.text,var&quot;#s473&quot;}, Combined{AbstractPlotting.meshscatter,var&quot;#s473&quot;}, Combined{AbstractPlotting.scatter,var&quot;#s473&quot;}, Combined{AbstractPlotting.mesh,var&quot;#s473&quot;}, Combined{AbstractPlotting.linesegments,var&quot;#s473&quot;}, Combined{AbstractPlotting.lines,var&quot;#s473&quot;}, Combined{AbstractPlotting.surface,var&quot;#s473&quot;}, Combined{AbstractPlotting.volume,var&quot;#s473&quot;}, Combined{AbstractPlotting.heatmap,var&quot;#s473&quot;}, Combined{AbstractPlotting.image,var&quot;#s473&quot;}} where var&quot;#s473&quot;&lt;:Tuple{Arg1}}, Tuple{Arg1}} where Arg1" href="#AbstractPlotting.atomic_limits-Union{Tuple{Union{Combined{AbstractPlotting.text,var&quot;#s473&quot;}, Combined{AbstractPlotting.meshscatter,var&quot;#s473&quot;}, Combined{AbstractPlotting.scatter,var&quot;#s473&quot;}, Combined{AbstractPlotting.mesh,var&quot;#s473&quot;}, Combined{AbstractPlotting.linesegments,var&quot;#s473&quot;}, Combined{AbstractPlotting.lines,var&quot;#s473&quot;}, Combined{AbstractPlotting.surface,var&quot;#s473&quot;}, Combined{AbstractPlotting.volume,var&quot;#s473&quot;}, Combined{AbstractPlotting.heatmap,var&quot;#s473&quot;}, Combined{AbstractPlotting.image,var&quot;#s473&quot;}} where var&quot;#s473&quot;&lt;:Tuple{Arg1}}, Tuple{Arg1}} where Arg1"><code>AbstractPlotting.atomic_limits</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Data limits calculate a minimal boundingbox from the data points in a plot. This doesn&#39;t include any transformations, markers etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/data_limits.jl#L12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.attributes_from-Tuple{Any,Any}" href="#AbstractPlotting.attributes_from-Tuple{Any,Any}"><code>AbstractPlotting.attributes_from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">attributes_from(PlotType, plot)</code></pre><p>Gets the attributes from plot, that are valid for PlotType</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.available_marker_symbols-Tuple{}" href="#AbstractPlotting.available_marker_symbols-Tuple{}"><code>AbstractPlotting.available_marker_symbols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">available_marker_symbols()</code></pre><p>Displays all available marker symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1063-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.calculated_attributes!-Tuple{Any,Any}" href="#AbstractPlotting.calculated_attributes!-Tuple{Any,Any}"><code>AbstractPlotting.calculated_attributes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`calculated_attributes!(trait::Type{&lt;: AbstractPlot}, plot)`</code></pre><p>trait version of calculated_attributes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L26-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.calculated_attributes!-Tuple{T} where T" href="#AbstractPlotting.calculated_attributes!-Tuple{T} where T"><code>AbstractPlotting.calculated_attributes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`calculated_attributes!(plot::AbstractPlot)`</code></pre><p>Fill in values that can only be calculated when we have all other attributes filled</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L32-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.cam3d_turntable!-Tuple{Any}" href="#AbstractPlotting.cam3d_turntable!-Tuple{Any}"><code>AbstractPlotting.cam3d_turntable!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cam3d_turntable!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code>, which rotates around the plot&#39;s axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/camera3d.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.check_line_pattern-Tuple{Any}" href="#AbstractPlotting.check_line_pattern-Tuple{Any}"><code>AbstractPlotting.check_line_pattern</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if the linestyle format provided as a string contains only dashes and dots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.close2square-Tuple{Real}" href="#AbstractPlotting.close2square-Tuple{Real}"><code>AbstractPlotting.close2square</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns (N1, N2) with <code>N1 x N2 == n</code>. N2 might become 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L237-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.colorbuffer" href="#AbstractPlotting.colorbuffer"><code>AbstractPlotting.colorbuffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">colorbuffer(scene, format::ImageStorageFormat = JuliaNative)
colorbuffer(screen, format::ImageStorageFormat = JuliaNative)</code></pre><p>Returns the content of the given scene or screen rasterised to a Matrix of Colors. The return type is backend-dependent, but will be some form of RGB or RGBA.</p><ul><li><code>format = JuliaNative</code> : Returns a buffer in the format of standard julia images (dims permuted and one reversed)</li><li><code>format = GLNative</code> : Returns a more efficient format buffer for GLMakie which can be directly                       used in FFMPEG without conversion</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/display.jl#L399-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.current_scene-Tuple{}" href="#AbstractPlotting.current_scene-Tuple{}"><code>AbstractPlotting.current_scene</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the current active scene (the last scene that got created)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L447-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.default_plot_signatures-Tuple{Any,Any,Any}" href="#AbstractPlotting.default_plot_signatures-Tuple{Any,Any,Any}"><code>AbstractPlotting.default_plot_signatures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> default_plot_signatures(funcname, funcname!, PlotType)</code></pre><p>Creates all the different overloads for <code>funcname</code> that need to be supported for the plotting frontend! Since we add all these signatures to different functions, we make it reusable with this function. The <code>Core.@__doc__</code> macro transfers the docstring given to the Recipe into the functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/recipes.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.elconvert-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{Type{T1},AbstractArray{T2,N}}} where N where T2 where T1" href="#AbstractPlotting.elconvert-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{Type{T1},AbstractArray{T2,N}}} where N where T2 where T1"><code>AbstractPlotting.elconvert</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Converts the elemen array type to <code>T1</code> without making a copy if the element type matches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L267-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.extract_scene_attributes!-Tuple{Any}" href="#AbstractPlotting.extract_scene_attributes!-Tuple{Any}"><code>AbstractPlotting.extract_scene_attributes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extract_scene_attributes!(attributes)</code></pre><p>removes all scene attributes from <code>attributes</code> and returns them in a new Attribute dict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L719-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.find_font_for_char-Tuple{Char,FreeTypeAbstraction.FTFont}" href="#AbstractPlotting.find_font_for_char-Tuple{Char,FreeTypeAbstraction.FTFont}"><code>AbstractPlotting.find_font_for_char</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_font_for_char(c::Char, font::NativeFont)</code></pre><p>Finds the best font for a character from a list of fallback fonts, that get chosen if <code>font</code> can&#39;t represent char <code>c</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/texture_atlas.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.find_node_expressions-Tuple{Expr}" href="#AbstractPlotting.find_node_expressions-Tuple{Expr}"><code>AbstractPlotting.find_node_expressions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a set of all sub-expressions in an expression that look like some_expression</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/liftmacro.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.flatten_combined" href="#AbstractPlotting.flatten_combined"><code>AbstractPlotting.flatten_combined</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Flattens all the combined plots and returns a Vector of Atomic plots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L470-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.from_dict-Union{Tuple{T}, Tuple{Type{T},Any}} where T" href="#AbstractPlotting.from_dict-Union{Tuple{T}, Tuple{Type{T},Any}} where T"><code>AbstractPlotting.from_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from_dict(::Type{T}, dict)</code></pre><p>Creates the type <code>T</code> from the fields in dict. Automatically converts to the correct node types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.frustum-Union{Tuple{T}, NTuple{6,T}} where T" href="#AbstractPlotting.frustum-Union{Tuple{T}, NTuple{6,T}} where T"><code>AbstractPlotting.frustum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Create view frustum

Parameters
----------
    left : float
     Left coordinate of the field of view.
    right : float
     Left coordinate of the field of view.
    bottom : float
     Bottom coordinate of the field of view.
    top : float
     Top coordinate of the field of view.
    znear : float
     Near coordinate of the field of view.
    zfar : float
     Far coordinate of the field of view.

Returns
-------
    M : array
     View frustum matrix (4x4).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/projection_math.jl#L55-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.get_attribute-Tuple{AbstractPlotting.ObservableAttributes,Symbol}" href="#AbstractPlotting.get_attribute-Tuple{AbstractPlotting.ObservableAttributes,Symbol}"><code>AbstractPlotting.get_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_attribute(dict::ObservableAttributes, key::Key)</code></pre><p>Gets the attribute at <code>key</code>, converts it and extracts the value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/attributes.jl#L265-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.get_lifted_attribute-Tuple{AbstractPlotting.ObservableAttributes,Symbol}" href="#AbstractPlotting.get_lifted_attribute-Tuple{AbstractPlotting.ObservableAttributes,Symbol}"><code>AbstractPlotting.get_lifted_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_attribute(dict::ObservableAttributes, key::Key)</code></pre><p>Gets the attribute at <code>key</code> as a converted signal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/attributes.jl#L273-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.get_value-Tuple{AbstractPlotting.ObservableAttributes,Symbol}" href="#AbstractPlotting.get_value-Tuple{AbstractPlotting.ObservableAttributes,Symbol}"><code>AbstractPlotting.get_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_value(attributes::ObservableAttributes, field::Symbol)</code></pre><p>Gets the value for <code>field</code>. The values are looked up in the following order:     1) user given at creation time     2) theme given     3) global defaults</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/attributes.jl#L115-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.getscreen-Tuple{Scene}" href="#AbstractPlotting.getscreen-Tuple{Scene}"><code>AbstractPlotting.getscreen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getscreen(scene::Scene)</code></pre><p>Gets the current screen a scene is associated with. Returns nothing if not yet displayed on a screen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.glyph_positions-Tuple{AbstractString,Any,Any,Any,Any,Any,Any,Any}" href="#AbstractPlotting.glyph_positions-Tuple{AbstractString,Any,Any,Any,Any,Any,Any,Any}"><code>AbstractPlotting.glyph_positions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">glyph_positions(str::AbstractString, font_per_char, fontscale_px, halign, valign, lineheight_factor, justification, rotation)</code></pre><p>Calculate the positions for each glyph in a string given a certain font, font size, alignment, etc. This layout in text coordinates, relative to the anchor point [0,0] can then be translated and rotated to wherever it is needed in the plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/layouting.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.interpolated_getindex-Tuple{AbstractArray,Number,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}" href="#AbstractPlotting.interpolated_getindex-Tuple{AbstractArray,Number,Union{Tuple{Vararg{T,N}}, StaticArrays.StaticArray{Tuple{N},T,1}} where T where N}"><code>AbstractPlotting.interpolated_getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolated_getindex(cmap::AbstractArray, value::AbstractFloat, norm = (0.0, 1.0))</code></pre><p>Like getindex, but accepts values between 0..1 and interpolates those to the full range. You can use <code>norm</code>, to change the range of 0..1 to whatever you want.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/colorsampler.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.interpolated_getindex-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractFloat}} where T" href="#AbstractPlotting.interpolated_getindex-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,AbstractFloat}} where T"><code>AbstractPlotting.interpolated_getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolated_getindex(cmap::AbstractArray, value::AbstractFloat)</code></pre><p>Like getindex, but accepts values between 0..1 for <code>value</code> and interpolates those to the full range of <code>cmap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/colorsampler.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.layout_text-Tuple{AbstractString,Union{Number, AbstractArray{T,1} where T},Any,Any,Any,Any,Any,Any}" href="#AbstractPlotting.layout_text-Tuple{AbstractString,Union{Number, AbstractArray{T,1} where T},Any,Any,Any,Any,Any,Any}"><code>AbstractPlotting.layout_text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">layout_text(
    string::AbstractString, textsize::Union{AbstractVector, Number},
    font, align, rotation, model, justification, lineheight
)</code></pre><p>Compute a Glyphlayout for a <code>string</code> given textsize, font, align, rotation, model, justification, and lineheight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/layouting.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.lookat-Union{Tuple{T}, Tuple{Vec{3,T},Vec{3,T},Vec{3,T}}} where T" href="#AbstractPlotting.lookat-Union{Tuple{T}, Tuple{Vec{3,T},Vec{3,T},Vec{3,T}}} where T"><code>AbstractPlotting.lookat</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>view = lookat(eyeposition, lookat, up)</code> creates a view matrix with the eye located at <code>eyeposition</code> and looking at position <code>lookat</code>, with the top of the window corresponding to the direction <code>up</code>. Only the component of <code>up</code> that is perpendicular to the vector pointing from <code>eyeposition</code> to <code>lookat</code> will be used.  All inputs must be supplied as 3-vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/projection_math.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.mouse_in_scene-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}" href="#AbstractPlotting.mouse_in_scene-Tuple{Union{AbstractScene, AbstractPlotting.ScenePlot}}"><code>AbstractPlotting.mouse_in_scene</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mouse_in_scene(scene::Scene)</code></pre><p>returns the mouseposition relative to <code>scene</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L66-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.peaks" href="#AbstractPlotting.peaks"><code>AbstractPlotting.peaks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">peaks([n=49])</code></pre><p>Return a nonlinear function on a grid.  Useful for test cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.perspectiveprojection-Union{Tuple{T}, NTuple{4,T}} where T" href="#AbstractPlotting.perspectiveprojection-Union{Tuple{T}, NTuple{4,T}} where T"><code>AbstractPlotting.perspectiveprojection</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>proj = perspectiveprojection([T], fovy, aspect, znear, zfar)</code> defines a projection matrix with a given angular field-of-view <code>fovy</code> along the y-axis (measured in degrees), the specified <code>aspect</code> ratio, and near and far clipping planes <code>znear</code>, <code>zfar</code>. Optionally specify the element type <code>T</code> of the matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/projection_math.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.perspectiveprojection-Union{Tuple{T}, Tuple{GeometryBasics.HyperRectangle{2,T} where T,T,T,T}} where T" href="#AbstractPlotting.perspectiveprojection-Union{Tuple{T}, Tuple{GeometryBasics.HyperRectangle{2,T} where T,T,T,T}} where T"><code>AbstractPlotting.perspectiveprojection</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>proj = perspectiveprojection([T], rect, fov, near, far)</code> defines the projection ratio in terms of the rectangular view size <code>rect</code> rather than the aspect ratio.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/camera/projection_math.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.plots_from_camera-Tuple{Scene}" href="#AbstractPlotting.plots_from_camera-Tuple{Scene}"><code>AbstractPlotting.plots_from_camera</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fetches all plots sharing the same camera</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/scenes.jl#L458-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.plottype-Tuple" href="#AbstractPlotting.plottype-Tuple"><code>AbstractPlotting.plottype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`plottype(plot_args...)`</code></pre><p>Any custom argument combination that has a preferred way to be plotted should overload this. e.g.:</p><pre><code class="language-example">    # make plot(rand(5, 5, 5)) plot as a volume
    plottype(x::Array{&lt;: AbstractFloat, 3}) = Volume</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L531-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.plottype-Union{Tuple{T}, Tuple{Type{var&quot;#s167&quot;} where var&quot;#s167&quot;&lt;:(Combined{Any,T} where T),Type{var&quot;#s81&quot;} where var&quot;#s81&quot;&lt;:(Combined{T,T1} where T1)}} where T" href="#AbstractPlotting.plottype-Union{Tuple{T}, Tuple{Type{var&quot;#s167&quot;} where var&quot;#s167&quot;&lt;:(Combined{Any,T} where T),Type{var&quot;#s81&quot;} where var&quot;#s81&quot;&lt;:(Combined{T,T1} where T1)}} where T"><code>AbstractPlotting.plottype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plottype(P1::Type{&lt;: Combined{T1}}, P2::Type{&lt;: Combined{T2}})</code></pre><p>Chooses the more concrete plot type ```example function convert_arguments(P::PlotFunc, args...)     ptype = plottype(P, Lines)     ... end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L566-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.primary_resolution" href="#AbstractPlotting.primary_resolution"><code>AbstractPlotting.primary_resolution</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Returns the resolution of the primary monitor. If the primary monitor can&#39;t be accessed, returns (1920, 1080) (full hd)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/theming.jl#L23-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.print_rec" href="#AbstractPlotting.print_rec"><code>AbstractPlotting.print_rec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">print_rec(io::IO, dict, indent::Int = 1[; extended = false])</code></pre><p>Traverses a dictionary <code>dict</code> and recursively print out its keys and values in a nicely-indented format.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/documentation/documentation.jl#L206-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.raw_boundingbox-Tuple{Union{Combined{AbstractPlotting.text,Arg}, Combined{AbstractPlotting.meshscatter,Arg}, Combined{AbstractPlotting.scatter,Arg}, Combined{AbstractPlotting.mesh,Arg}, Combined{AbstractPlotting.linesegments,Arg}, Combined{AbstractPlotting.lines,Arg}, Combined{AbstractPlotting.surface,Arg}, Combined{AbstractPlotting.volume,Arg}, Combined{AbstractPlotting.heatmap,Arg}, Combined{AbstractPlotting.image,Arg}} where Arg}" href="#AbstractPlotting.raw_boundingbox-Tuple{Union{Combined{AbstractPlotting.text,Arg}, Combined{AbstractPlotting.meshscatter,Arg}, Combined{AbstractPlotting.scatter,Arg}, Combined{AbstractPlotting.mesh,Arg}, Combined{AbstractPlotting.linesegments,Arg}, Combined{AbstractPlotting.lines,Arg}, Combined{AbstractPlotting.surface,Arg}, Combined{AbstractPlotting.volume,Arg}, Combined{AbstractPlotting.heatmap,Arg}, Combined{AbstractPlotting.image,Arg}} where Arg}"><code>AbstractPlotting.raw_boundingbox</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the exact boundingbox of a Scene/Plot, without considering any transformation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/boundingbox.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.reasonable_resolution-Tuple{}" href="#AbstractPlotting.reasonable_resolution-Tuple{}"><code>AbstractPlotting.reasonable_resolution</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a reasonable resolution for the main monitor. (right now just half the resolution of the main monitor)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/theming.jl#L29-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.replace_node_expressions!-Tuple{Expr,Any}" href="#AbstractPlotting.replace_node_expressions!-Tuple{Expr,Any}"><code>AbstractPlotting.replace_node_expressions!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replaces every subexpression that looks like a node expression with a substitute symbol stored in <code>exprdict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/liftmacro.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.resample-Tuple{AbstractArray{T,1} where T,Integer}" href="#AbstractPlotting.resample-Tuple{AbstractArray{T,1} where T,Integer}"><code>AbstractPlotting.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resample(A::AbstractVector, len::Integer)</code></pre><p>Resample a vector with linear interpolation to have length <code>len</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L7-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.resampled_colors-Tuple{Any,Integer}" href="#AbstractPlotting.resampled_colors-Tuple{Any,Integer}"><code>AbstractPlotting.resampled_colors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resampled_colors(attributes::Attributes, levels::Integer)</code></pre><p>Resample the color attribute from <code>attributes</code>. Resamples <code>:colormap</code> if present, or repeats <code>:color</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.rotatedrect-Tuple{GeometryBasics.HyperRectangle{2,T} where T,Any}" href="#AbstractPlotting.rotatedrect-Tuple{GeometryBasics.HyperRectangle{2,T} where T,Any}"><code>AbstractPlotting.rotatedrect</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate an approximation of a tight rectangle around a 2D rectangle rotated by <code>angle</code> radians. This is not perfect but works well enough. Check an A vs X to see the difference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/layouting/boundingbox.jl#L206-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.safe_off-Tuple{Observables.AbstractObservable,Any}" href="#AbstractPlotting.safe_off-Tuple{Observables.AbstractObservable,Any}"><code>AbstractPlotting.safe_off</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Observables.off but without throwing an error</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/nodes.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.screen_relative-Tuple{Scene,Any}" href="#AbstractPlotting.screen_relative-Tuple{Scene,Any}"><code>AbstractPlotting.screen_relative</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Normalizes mouse position relative to the screen rectangle</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interaction/interactive_api.jl#L102-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.sdistancefield-Tuple{Any,Any,Any}" href="#AbstractPlotting.sdistancefield-Tuple{Any,Any,Any}"><code>AbstractPlotting.sdistancefield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sdistancefield(img, downsample, pad)</code></pre><p>Calculates a distance fields, that is downsampled <code>downsample</code> time, with a padding applied of <code>pad</code>. The padding is in units after downscaling!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/texture_atlas.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.setlims!" href="#AbstractPlotting.setlims!"><code>AbstractPlotting.setlims!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setlims!(scene::Scene, min_max::NTuple{2, Real}, dim=1)</code></pre><p>Sets the limits of the scene for dim=1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.showlibrary-Tuple{Symbol}" href="#AbstractPlotting.showlibrary-Tuple{Symbol}"><code>AbstractPlotting.showlibrary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">showlibrary(lib::Symbol)::Scene</code></pre><p>Shows all colour gradients in the given library. Returns a Scene with these colour gradients arranged as horizontal colourbars.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/basic_recipes/convenience_functions.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.streamplot_impl-Union{Tuple{T}, Tuple{N}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any,Any}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any,Any,Any}} where T where N" href="#AbstractPlotting.streamplot_impl-Union{Tuple{T}, Tuple{N}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any,Any}, Tuple{Any,Any,GeometryBasics.HyperRectangle{N,T},Any,Any,Any,Any}} where T where N"><code>AbstractPlotting.streamplot_impl</code></a> — <span class="docstring-category">Method</span></header><section><div><p>streamplot_impl(CallType, f, limits::Rect{N, T}, resolutionND, stepsize)</p><p>Code adapted from an example implementation by Moritz Schauer (@mschauer) from https://github.com/JuliaPlots/Makie.jl/issues/355#issuecomment-504449775</p><p>Background: The algorithm puts an arrow somewhere and extends the streamline in both directions from there. Then, it chooses a new position (from the remaining ones), repeating the the exercise until the streamline gets blocked, from which on a new starting point, the process repeats.</p><p>So, ideally, the new starting points for streamlines are not too close to current streamlines.</p><p>Links:</p><p><a href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">Quasirandom sequences</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/basic_recipes/streamplot.jl#L51-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.surface_normals-Tuple{Any,Any,Any}" href="#AbstractPlotting.surface_normals-Tuple{Any,Any,Any}"><code>AbstractPlotting.surface_normals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">surface_normals(x, y, z)</code></pre><p>Normals for a surface defined on the grid xy</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/utilities/utilities.jl#L299-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ticklabels-Tuple{Any}" href="#AbstractPlotting.ticklabels-Tuple{Any}"><code>AbstractPlotting.ticklabels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ticklabels(scene)</code></pre><p>Returns the all the axis tick labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.tickranges-Tuple{Any}" href="#AbstractPlotting.tickranges-Tuple{Any}"><code>AbstractPlotting.tickranges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tickranges(scene)</code></pre><p>Returns the tick ranges along all axes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.tickrotations!-Tuple{Scene,Any}" href="#AbstractPlotting.tickrotations!-Tuple{Scene,Any}"><code>AbstractPlotting.tickrotations!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xtickrotation!([scene,] zangle)</code></pre><p>Set the rotation of all tick labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L296-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.tickrotations-Tuple{Any}" href="#AbstractPlotting.tickrotations-Tuple{Any}"><code>AbstractPlotting.tickrotations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tickrotations(scene)</code></pre><p>Returns the rotation of all tick labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.ticks!" href="#AbstractPlotting.ticks!"><code>AbstractPlotting.ticks!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ticks!([scene,]; tickranges=tickranges(scene), ticklabels=ticklabels(scene))</code></pre><p>Set the tick labels and ranges along all axes. The respective labels and ranges along each axis must be of the same length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/shorthands.jl#L204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_func-Union{Tuple{Type{var&quot;#s611&quot;} where var&quot;#s611&quot;&lt;:AbstractPlot{F}}, Tuple{F}} where F" href="#AbstractPlotting.to_func-Union{Tuple{Type{var&quot;#s611&quot;} where var&quot;#s611&quot;&lt;:AbstractPlot{F}}, Tuple{F}} where F"><code>AbstractPlotting.to_func</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_func(Typ)</code></pre><p>Maps the input of a Type name to its cooresponding function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/documentation/documentation.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{AbstractArray{T,1} where T}" href="#AbstractPlotting.to_spritemarker-Tuple{AbstractArray{T,1} where T}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Vector of anything that is accepted as a single marker will give each point it&#39;s own marker. Note that it needs to be a uniform vector with the same element type!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1127-L1130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{AbstractArray{var&quot;#s168&quot;,2} where var&quot;#s168&quot;&lt;:Colorant}" href="#AbstractPlotting.to_spritemarker-Tuple{AbstractArray{var&quot;#s168&quot;,2} where var&quot;#s168&quot;&lt;:Colorant}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Any AbstractMatrix{&lt;: Colorant} or other image type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1107-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Array{var&quot;#s168&quot;,2} where var&quot;#s168&quot;&lt;:AbstractFloat}" href="#AbstractPlotting.to_spritemarker-Tuple{Array{var&quot;#s168&quot;,2} where var&quot;#s168&quot;&lt;:AbstractFloat}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Matrix of AbstractFloat will be interpreted as a distancefield (negative numbers outside shape, positive inside)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1102-L1104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Char}" href="#AbstractPlotting.to_spritemarker-Tuple{Char}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_spritemarker(b, marker::Char)</code></pre><p>Any <code>Char</code>, including unicode</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1095-L1099">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_spritemarker-Tuple{Symbol}" href="#AbstractPlotting.to_spritemarker-Tuple{Symbol}"><code>AbstractPlotting.to_spritemarker</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A <code>Symbol</code> - Available options can be printed with <code>available_marker_symbols()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L1112-L1114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_string-Tuple{Function}" href="#AbstractPlotting.to_string-Tuple{Function}"><code>AbstractPlotting.to_string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_string(func)</code></pre><p>Turns the input of a function name or plot Type into a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/documentation/documentation.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_triangles-Tuple{AbstractArray{Int64,1}}" href="#AbstractPlotting.to_triangles-Tuple{AbstractArray{Int64,1}}"><code>AbstractPlotting.to_triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_triangles(indices)</code></pre><p>Convert a representation of triangle point indices <code>indices</code> to its canonical representation as a <code>Vector{AbstractPlotting.GLTriangleFace}</code>. <code>indices</code> can be any of the following:</p><ul><li>An <code>AbstractVector{Int}</code>, containing groups of 3 1-based indices,</li><li>An <code>AbstractVector{UIn32}</code>, containing groups of 3 0-based indices,</li><li>An <code>AbstractVector</code> of <code>TriangleFace</code> objects,</li><li>An <code>AbstractMatrix</code> of <code>Integer</code>s, where each row is a triangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L496-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_type-Tuple{Function}" href="#AbstractPlotting.to_type-Tuple{Function}"><code>AbstractPlotting.to_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_type(func)</code></pre><p>Maps the input of a function name to its cooresponding Type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/documentation/documentation.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.to_vertices-Union{Tuple{AbstractArray{var&quot;#s168&quot;,1} where var&quot;#s168&quot;&lt;:Union{Tuple{T,T,T}, StaticArrays.StaticArray{Tuple{3},T,1}}}, Tuple{T}} where T" href="#AbstractPlotting.to_vertices-Union{Tuple{AbstractArray{var&quot;#s168&quot;,1} where var&quot;#s168&quot;&lt;:Union{Tuple{T,T,T}, StaticArrays.StaticArray{Tuple{3},T,1}}}, Tuple{T}} where T"><code>AbstractPlotting.to_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_vertices(v)</code></pre><p>Converts a representation of vertices <code>v</code> to its canonical representation as a <code>Vector{Point3f0}</code>. <code>v</code> can be:</p><ul><li><p>An <code>AbstractVector</code> of 3-element <code>Tuple</code>s or <code>StaticVector</code>s,</p></li><li><p>An <code>AbstractVector</code> of <code>Tuple</code>s or <code>StaticVector</code>s, in which case exta dimensions will be either truncated or padded with zeros as required,</p></li><li><p>An <code>AbstractMatrix</code>&quot;</p><ul><li>if <code>v</code> has 2 or 3 rows, it will treat each column as a vertex,</li><li>otherwise if <code>v</code> has 2 or 3 columns, it will treat each row as a vertex.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/conversions.jl#L527-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractPlotting.used_attributes-Tuple{Any,Vararg{Any,N} where N}" href="#AbstractPlotting.used_attributes-Tuple{Any,Vararg{Any,N} where N}"><code>AbstractPlotting.used_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">used_attributes(args...) = ()</code></pre><p>function used to indicate what keyword args one wants to get passed in <code>convert_arguments</code>. Usage:</p><pre><code class="language-example">    struct MyType end
    used_attributes(::MyType) = (:attribute,)
    function convert_arguments(x::MyType; attribute = 1)
        ...
    end
    # attribute will get passed to convert_arguments
    # without keyword_verload, this wouldn&#39;t happen
    plot(MyType, attribute = 2)
    #You can also use the convenience macro, to overload convert_arguments in one step:
    @keywords convert_arguments(x::MyType; attribute = 1)
        ...
    end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPlots/AbstractPlotting.jl/blob/de7fb39c3332c31c9cee71a73396cb98cea5bcd1/src/interfaces.jl#L418-L437">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="faq.html">« Frequently Asked Questions</a><a class="docs-footer-nextpage" href="makielayout/reference.html">API Reference MakieLayout »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 21 March 2021 10:47">Sunday 21 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
